[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi hi, mình là Kiên"
  },
  {
    "objectID": "posts/sql-tutorial/index.html",
    "href": "posts/sql-tutorial/index.html",
    "title": "SQL Tutorial",
    "section": "",
    "text": "SQL Tutorial\nWelcome to my SQL learning journal! In this blog, we will embark on an exciting journey to explore the world of Structured Query Language (SQL). SQL is a powerful tool used for managing and manipulating data in relational databases. Whether you’re a beginner or an experienced data professional, this blog will provide you with valuable insights, tips, and tutorials to enhance your SQL skills. So, let’s dive in and unlock the potential of SQL together!"
  },
  {
    "objectID": "posts/docker-tutorial/index.html",
    "href": "posts/docker-tutorial/index.html",
    "title": "Docker Tutorial",
    "section": "",
    "text": "Ghi chú lại những tổng kết quan trọng trong quá trình học và thực hành Docker\n\n\n\nDocker là một nền tảng ảo hóa dựa trên container, giúp đơn giản hóa quá trình triển khai và quản lý ứng dụng. Containers là môi trường đóng gói chứa tất cả những thứ cần thiết để chạy một ứng dụng, bao gồm mã nguồn, thư viện, biến môi trường và cài đặt hệ thống.\n\n\n\n\n\nMột image là một môi trường đóng gói có chứa tất cả các thông tin cần thiết để chạy một ứng dụng, bao gồm cả hệ điều hành, thư viện, và ứng dụng cụ thể.\ndocker pull ubuntu:latest\n\n\n\nContainer là một thực thể chạy của một image. Nó cung cấp một môi trường cô lập để chạy ứng dụng mà không ảnh hưởng đến hệ thống chủ.\ndocker run -d -p 8080:80 --name my-container my-app\n\n\n\nDockerfile là một tệp văn bản chứa các hướng dẫn để tạo một image. Nó mô tả cách image nên được xây dựng.\n# Dockerfile example\nFROM node:14\nWORKDIR /app\nCOPY . .\nRUN npm install\nCMD [\"npm\", \"start\"]\n\n\n\nDocker Compose là công cụ giúp định nghĩa và chạy các dịch vụ được đóng gói trong các containers. Nó giúp quản lý nhiều containers và các cài đặt liên quan.\nversion: '3'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - \"8080:80\"\n\n\n\nDocker Registry là nơi lưu trữ và chia sẻ các images. Docker Hub là một ví dụ của Docker Registry.\ndocker push username/my-app:latest\n\n\n\n\n\n\n\n\n\n\n\n\n\nLệnh\nTùy Chọn / Tham Số\nChức Năng\nViết Tắt\n\n\n\n\ndocker run\n-d\nChạy container ở chế độ nền (detached).\nDetached\n\n\n\n--name\nĐặt tên cho container.\nName\n\n\n\n--publish (-p)\nChuyển tiếp cổng giữa máy host và container.\nPort\n\n\n\n--volume (-v)\nMount thư mục hoặc volume giữa máy host và container.\nVolume\n\n\ndocker build\n-t\nGắn thêm thông tin về thời gian (timestamps).\nTag\n\n\ndocker exec\n-i\nMở chế độ tương tác khi chạy lệnh trong container.\nInteractive\n\n\n\n-t\nTạo một pseudo-TTY để tương tác với container.\nTTY\n\n\ndocker-compose\n-f\nChỉ định Docker Compose file.\nFile\n\n\n\n\n\n\nNgắn Gọn: DevContainer là một khái niệm trong Docker giúp đơn giản hóa quá trình cấu hình môi trường phát triển. Nó sử dụng Docker để xây dựng một container chứa môi trường phát triển cụ thể cho một dự án, giúp đảm bảo rằng tất cả các thành viên trong đội làm việc trên cùng một nền tảng.\nTại sao Nên Sử Dụng DevContainer?\n\nĐồng Nhất Môi Trường Phát Triển:\n\nDevContainer giúp đảm bảo rằng mọi người trong đội làm việc với cùng một môi trường phát triển, tránh sự không nhất quán và xung đột.\n\nDễ Quản Lý và Phát Triển:\n\nCấu hình được xác định trong một tệp cấu hình, giúp quản lý dự án và môi trường phát triển trở nên đơn giản.\n\nTích Hợp Dễ Dàng với IDE:\n\nCác IDE phổ biến như Visual Studio Code hỗ trợ nhanh chóng và dễ dàng tích hợp DevContainer vào quá trình phát triển.\n\n\n\n\nDưới đây là bảng chi tiết với các tùy chọn cụ thể của mỗi thuộc tính trong devcontainer.json:\n\n\n\n\n\n\n\n\n\nThuộc Tính\nTùy Chọn\nMô Tả\nVí Dụ\n\n\n\n\nname\n-\nTên của DevContainer, cung cấp nhãn cho môi trường phát triển.\n\"Node.js\"\n\n\nimage\n-\nTên của hình ảnh trong một container registry (Docker Hub, GitHub Container Registry, Azure Container Registry) mà VS Code sẽ sử dụng để tạo DevContainer.\n\"mcr.microsoft.com/devcontainers/javascript-node:0-18\"\n\n\ndockerfile\n-\nCho phép sử dụng một Dockerfile tùy chỉnh thay vì tham chiếu đến một hình ảnh.\n\"Dockerfile\"\n\n\ncustomizations\nvscode\nCấu hình các thuộc tính cụ thể cho từng công cụ, chẳng hạn như cài đặt và cấu hình extensions cho VS Code.\n\"customizations\": { \"vscode\": { \"settings\": {}, \"extensions\": [\"streetsidesoftware.code-spell-checker\"] } }\n\n\nsettings\n-\nThêm giá trị mặc định từ settings.json vào một tệp cài đặt riêng biệt dành cho container/máy, chẳng hạn như \"terminal.integrated.defaultProfile.linux\": \"bash\".\n\"settings\": { \"terminal.integrated.defaultProfile.linux\": \"bash\" }\n\n\nextensions\n-\nMột mảng các ID của extensions cần được cài đặt bên trong container khi nó được tạo.\n\"extensions\": [\"streetsidesoftware.code-spell-checker\"]\n\n\nforwardPorts\n-\nLiệt kê các cổng bên trong container mà bạn muốn sẵn sàng ở cổng cục bộ.\n\"forwardPorts\": [3000]\n\n\nportsAttributes\n-\nĐặt các thuộc tính mặc định cho các cổng được chuyển tiếp cụ thể.\n\"portsAttributes\": { \"3000\": { \"label\": \"Hello Remote World\", \"onAutoForward\": \"notify\" } }\n\n\npostCreateCommand\n-\nMột chuỗi lệnh hoặc danh sách đối số lệnh để chạy sau khi container được tạo.\n\"postCreateCommand\": \"yarn install\"\n\n\nremoteUser\n-\nGhi đè người dùng mà VS Code chạy như trong container (cùng với các tiến trình con). Mặc định là containerUser.\n\"remoteUser\": \"root\"\n\n\nfeatures\n-\nMột đối tượng chứa các tính năng cụ thể của Dev Container để thêm vào.\n\"features\": { \"my-feature\": true }\n\n\nbuild\ndockerfile, context\nĐối tượng mô tả cách xây dựng Dev Container từ Dockerfile hoặc Docker Compose.\n\"build\": { \"dockerfile\": \"Dockerfile\", \"context\": \"..\" }\n\n\nrunArgs\n-\nMảng các đối số thêm vào lệnh docker run khi khởi chạy container.\n\"runArgs\": [\"--user\", \"1000:1000\"]\n\n\npostCreateCommand\n-\nMột chuỗi lệnh hoặc danh sách đối số lệnh để chạy sau khi container được tạo.\n\"postCreateCommand\": \"yarn install\"\n\n\nshutdownAction\nstopContainer, none\nHành động mà VS Code sẽ thực hiện khi bạn đóng một cửa sổ hoặc tab trong đó Dev Container đang chạy.\n\"shutdownAction\": \"stopContainer\"\n\n\noverrideCommand\n-\nMột lệnh hoặc danh sách đối số lệnh để thay thế lệnh mặc định khi khởi chạy container.\n\"overrideCommand\": \"npm start\"\n\n\nremoteUser\n-\nGhi đè người dùng mà VS Code chạy như trong container (cùng với các tiến trình con). Mặc định là containerUser.\n\"remoteUser\": \"root\"\n\n\nworkspaceFolder\n/workspace\nĐường dẫn trong container mà mọi hoạt động của VS Code sẽ được thực hiện trong đó.\n\"workspaceFolder\": \"/workspace\"\n\n\nworkspaceMount\n-\nCấu hình mount của thư mục workspace từ máy host vào container.\n\n\n\n\nChú Ý: - Mỗi tùy chọn cụ thể của thuộc tính được liệt kê trong cột “Tùy Chọn” của bảng. - Các giải thích chi tiết cung cấp hiểu biết về mục đích và cách sử dụng mỗi tùy chọn cụ thể. - Các ví dụ minh họa giúp làm rõ cách áp dụng mỗi tùy chọn trong một ngữ cảnh thực tế.\n\n\n\n\n\n\nvscode:\n\nsettings: Cấu hình settings.json cho VS Code bên trong container.\n\nVí Dụ: { \"settings\": { \"python.linting.enabled\": true } }\n\nextensions: Danh sách các extension ID cần cài đặt trong VS Code.\n\nVí Dụ: [\"ms-python.python\"]\n\n\n\n\n\n\n\n&lt;setting&gt;: Các thuộc tính cụ thể của settings.json.\n\nVí Dụ: { \"terminal.integrated.defaultProfile.linux\": \"bash\" }\n\n\n\n\n\n\n&lt;extension&gt;: ID của extension cần được cài đặt.\n\nVí Dụ: [\"streetsidesoftware.code-spell-checker\"]\n\n\n\n\n\n\n&lt;port&gt;: Cổng bên trong container mà bạn muốn sẵn sàng ở cổng cục bộ.\n\nVí Dụ: [3000, 5000]\n\n\n\n\n\n\n&lt;port&gt;:\n\nlabel: Nhãn mô tả cho cổng được chuyển tiếp.\n\nVí Dụ: \"Hello Remote World\"\n\nonAutoForward: Hành động khi cổng được chuyển tiếp tự động (notify/silent).\n\nVí Dụ: \"notify\"\n\n\n\n\n\n\n\n&lt;command&gt;: Chuỗi lệnh hoặc danh sách đối số lệnh để chạy sau khi container được tạo.\n\nVí Dụ: \"yarn install\"\n\n\n\n\n\n\nGiải Thích Ngắn Gọn: - Xác định tên dự án cho Docker Compose giúp phân biệt giữa các tài nguyên được tạo bởi cùng một file docker-compose.yml khi chúng chia sẻ không gian tên.\nVí Dụ:\ndocker-compose -p myproject up -d\n\n\n\nGiải Thích Ngắn Gọn: - Liên kết nhiều container cho phép chúng giao tiếp và làm việc cùng nhau, tạo ra một môi trường ứng dụng phức tạp với nhiều thành phần.\nVí Dụ:\nservices:\n  web:\n    image: nginx\n  api:\n    image: myapi\n  database:\n    image: postgres\n\n\n\nGiải Thích Ngắn Gọn: - Cấu hình các container riêng lẻ cho phép định rõ các thiết lập đặc biệt cho từng dịch vụ, giảm sự phụ thuộc giữa chúng.\nVí Dụ:\nservices:\n  web:\n    image: nginx\n    ports:\n      - \"80:80\"\n  api:\n    image: myapi\n    environment:\n      - DATABASE_URL=mydatabase\n  database:\n    image: postgres\n    volumes:\n      - ./data:/var/lib/postgresql/data\n\n\n\nGiải Thích Ngắn Gọn: - Phát triển trên một Docker host từ xa giúp lập trình viên làm việc trên môi trường mô phỏng, giả lập môi trường sản xuất một cách chính xác.\nVí Dụ:\ndocker-compose -H ssh://user@remote-host up -d\n\n\n\nversion: '3'\n\nservices:\n  frontend:\n    image: frontend\n    networks:\n      - mynetwork\n  backend:\n    image: backend\n    networks:\n      - mynetwork\n  database:\n    image: postgres\n    networks:\n      - mynetwork\n    volumes:\n      - ./data:/var/lib/postgresql/data\n\nnetworks:\n  mynetwork:\n\nDự án Docker Compose có tên là “myproject”.\nKết nối ba container (frontend, backend, database) trên một mạng có tên “mynetwork”.\nMỗi container có cấu hình riêng với cổng, biến môi trường, và thư mục dữ liệu.\nDự án cho phép phát triển cả ba container trên một Docker host từ xa nếu cần thiết.\n\n\n\n\n\n\n\nDockerfile là một tệp văn bản chứa một loạt các lệnh, mỗi lệnh đại diện cho một bước trong quá trình xây dựng một hình ảnh Docker. Nó mô tả cách một hình ảnh nên được xây dựng từ các thành phần khác nhau và cài đặt các phần mềm cần thiết.\n\n\n\n\n\n\n\n\n\n\n\nLệnh\nMô Tả\nVí Dụ\n\n\n\n\nFROM\nChọn hình ảnh cơ sở để bắt đầu xây dựng.\nFROM ubuntu:latest\n\n\nCOPY\nSao chép các tệp từ máy host vào hình ảnh.\nCOPY app.py /app/\n\n\nADD\nSao chép các tệp từ máy host hoặc URL vào hình ảnh.\nADD https://example.com/file.txt /app/\n\n\nRUN\nThực hiện các lệnh trong môi trường hình ảnh và tạo lớp mới.\nRUN apt-get update && apt-get install -y curl\n\n\nWORKDIR\nĐặt thư mục làm việc cho các lệnh sau đó.\nWORKDIR /app\n\n\nEXPOSE\nMô tả các cổng mà ứng dụng sẽ lắng nghe khi chạy.\nEXPOSE 80/tcp\n\n\nENV\nĐặt các biến môi trường cho hình ảnh.\nENV NODE_ENV production\n\n\nCMD hoặc ENTRYPOINT\nXác định lệnh mặc định khi container được chạy.\nCMD [\"python\", \"app.py\"]\n\n\nARG\nĐịnh nghĩa các biến mà người dùng có thể truyền vào lúc xây dựng.\nARG version=latest\n\n\nLABEL\nThêm các metadata (nhãn) vào hình ảnh.\nLABEL maintainer=\"admin@example.com\"\n\n\nVOLUME\nChỉ định các thư mục làm thư mục volume và được dùng để lưu trữ dữ liệu.\nVOLUME /data\n\n\nRUN, CMD, ENTRYPOINT\nCác lệnh có thể sử dụng dưới dạng shell hoặc mảng đối số.\nRUN apt-get update && apt-get install -y curl\n\n\n\nLưu Ý: - Một Dockerfile thường bắt đầu bằng lệnh FROM. - Các lệnh được thực thi theo thứ tự từ trên xuống dưới trong Dockerfile. - Có thể kết hợp nhiều lệnh trong một dòng bằng cách sử dụng &&. - Các lệnh CMD và ENTRYPOINT giúp xác định hành động mặc định khi container chạy.\nDockerfile là công cụ quan trọng để xây dựng hình ảnh Docker và tự động hóa quy trình triển khai ứng dụng.\n\n\n\n\nDocker Compose là công cụ giúp quản lý và triển khai ứng dụng đa-container trong môi trường Docker. Dưới đây là một bảng tổng hợp các lệnh và thuộc tính quan trọng trong Docker Compose:\n\n\n\n\n\n\n\n\n\n\nLệnh\nThuộc Tính\nKiểu Dữ Liệu\nMô Tả Chi Tiết\nVí Dụ\n\n\n\n\ndocker-compose up\n-\n-\nChạy các dịch vụ được định nghĩa trong file docker-compose.yml.\ndocker-compose up\n\n\ndocker-compose down\n-\n-\nDừng và xóa tất cả các container, mạng và dữ liệu đã tạo.\ndocker-compose down\n\n\ndocker-compose ps\n-\n-\nLiệt kê các container đang chạy.\ndocker-compose ps\n\n\ndocker-compose exec\n-\n-\nThực hiện lệnh bên trong một container.\ndocker-compose exec webserver ls\n\n\ndocker-compose logs\n-\n-\nXem logs của các dịch vụ.\ndocker-compose logs\n\n\ndocker-compose build\n-\n-\nXây dựng lại các images của dịch vụ.\ndocker-compose build\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThuộc Tính\nKiểu Dữ Liệu\nMô Tả Chi Tiết\nVí Dụ\n\n\n\n\nversion\n-\nPhiên bản của Docker Compose.\nversion: '3'\n\n\nservices\n-\nĐịnh nghĩa các dịch vụ, mỗi dịch vụ có các cài đặt riêng.\nservices: web, db\n\n\nimage\n-\nTên hình ảnh của dịch vụ.\nimage: nginx:latest\n\n\nbuild\n-\nXây dựng dịch vụ từ Dockerfile trong thư mục hiện tại hoặc chỉ định.\nbuild: ./web\n\n\nports\n-\nChuyển tiếp cổng giữa máy host và container.\nports: - \"8080:80\"\n\n\nvolumes\n-\nMount thư mục hoặc volume giữa máy host và container.\nvolumes: - ./data:/app/data\n\n\nenvironment\n-\nĐặt biến môi trường cho dịch vụ.\nenvironment: - DEBUG=True\n\n\ndepends_on\n-\nXác định các dịch vụ phụ thuộc cần chạy trước.\ndepends_on: - db\n\n\n\n\n\n\nversion: '3'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - \"8080:80\"\n    volumes:\n      - ./web:/app\n    environment:\n      - DEBUG=True\n  db:\n    image: postgres:latest\n    volumes:\n      - /var/lib/postgresql/data\n    environment:\n      - POSTGRES_PASSWORD=mysecretpassword\n\nĐịnh nghĩa hai dịch vụ: web (nginx) và db (PostgreSQL).\nDịch vụ web sử dụng hình ảnh nginx, chuyển tiếp cổng 8080 từ máy host vào cổng 80 của container, mount thư mục ./web vào /app, và đặt biến môi trường DEBUG là True.\nDịch vụ db sử dụng hình ảnh PostgreSQL, mount thư mục dữ liệu vào /var/lib/postgresql/data, và đặt mật khẩu PostgreSQL."
  },
  {
    "objectID": "posts/docker-tutorial/index.html#docker-là-gì",
    "href": "posts/docker-tutorial/index.html#docker-là-gì",
    "title": "Docker Tutorial",
    "section": "",
    "text": "Docker là một nền tảng ảo hóa dựa trên container, giúp đơn giản hóa quá trình triển khai và quản lý ứng dụng. Containers là môi trường đóng gói chứa tất cả những thứ cần thiết để chạy một ứng dụng, bao gồm mã nguồn, thư viện, biến môi trường và cài đặt hệ thống."
  },
  {
    "objectID": "posts/docker-tutorial/index.html#các-khái-niệm-cơ-bản",
    "href": "posts/docker-tutorial/index.html#các-khái-niệm-cơ-bản",
    "title": "Docker Tutorial",
    "section": "",
    "text": "Một image là một môi trường đóng gói có chứa tất cả các thông tin cần thiết để chạy một ứng dụng, bao gồm cả hệ điều hành, thư viện, và ứng dụng cụ thể.\ndocker pull ubuntu:latest\n\n\n\nContainer là một thực thể chạy của một image. Nó cung cấp một môi trường cô lập để chạy ứng dụng mà không ảnh hưởng đến hệ thống chủ.\ndocker run -d -p 8080:80 --name my-container my-app\n\n\n\nDockerfile là một tệp văn bản chứa các hướng dẫn để tạo một image. Nó mô tả cách image nên được xây dựng.\n# Dockerfile example\nFROM node:14\nWORKDIR /app\nCOPY . .\nRUN npm install\nCMD [\"npm\", \"start\"]\n\n\n\nDocker Compose là công cụ giúp định nghĩa và chạy các dịch vụ được đóng gói trong các containers. Nó giúp quản lý nhiều containers và các cài đặt liên quan.\nversion: '3'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - \"8080:80\"\n\n\n\nDocker Registry là nơi lưu trữ và chia sẻ các images. Docker Hub là một ví dụ của Docker Registry.\ndocker push username/my-app:latest"
  },
  {
    "objectID": "posts/docker-tutorial/index.html#các-lệnh-thường-dùng",
    "href": "posts/docker-tutorial/index.html#các-lệnh-thường-dùng",
    "title": "Docker Tutorial",
    "section": "",
    "text": "Lệnh\nTùy Chọn / Tham Số\nChức Năng\nViết Tắt\n\n\n\n\ndocker run\n-d\nChạy container ở chế độ nền (detached).\nDetached\n\n\n\n--name\nĐặt tên cho container.\nName\n\n\n\n--publish (-p)\nChuyển tiếp cổng giữa máy host và container.\nPort\n\n\n\n--volume (-v)\nMount thư mục hoặc volume giữa máy host và container.\nVolume\n\n\ndocker build\n-t\nGắn thêm thông tin về thời gian (timestamps).\nTag\n\n\ndocker exec\n-i\nMở chế độ tương tác khi chạy lệnh trong container.\nInteractive\n\n\n\n-t\nTạo một pseudo-TTY để tương tác với container.\nTTY\n\n\ndocker-compose\n-f\nChỉ định Docker Compose file.\nFile"
  },
  {
    "objectID": "posts/docker-tutorial/index.html#devcontainer-là-gì",
    "href": "posts/docker-tutorial/index.html#devcontainer-là-gì",
    "title": "Docker Tutorial",
    "section": "",
    "text": "Ngắn Gọn: DevContainer là một khái niệm trong Docker giúp đơn giản hóa quá trình cấu hình môi trường phát triển. Nó sử dụng Docker để xây dựng một container chứa môi trường phát triển cụ thể cho một dự án, giúp đảm bảo rằng tất cả các thành viên trong đội làm việc trên cùng một nền tảng.\nTại sao Nên Sử Dụng DevContainer?\n\nĐồng Nhất Môi Trường Phát Triển:\n\nDevContainer giúp đảm bảo rằng mọi người trong đội làm việc với cùng một môi trường phát triển, tránh sự không nhất quán và xung đột.\n\nDễ Quản Lý và Phát Triển:\n\nCấu hình được xác định trong một tệp cấu hình, giúp quản lý dự án và môi trường phát triển trở nên đơn giản.\n\nTích Hợp Dễ Dàng với IDE:\n\nCác IDE phổ biến như Visual Studio Code hỗ trợ nhanh chóng và dễ dàng tích hợp DevContainer vào quá trình phát triển.\n\n\n\n\nDưới đây là bảng chi tiết với các tùy chọn cụ thể của mỗi thuộc tính trong devcontainer.json:\n\n\n\n\n\n\n\n\n\nThuộc Tính\nTùy Chọn\nMô Tả\nVí Dụ\n\n\n\n\nname\n-\nTên của DevContainer, cung cấp nhãn cho môi trường phát triển.\n\"Node.js\"\n\n\nimage\n-\nTên của hình ảnh trong một container registry (Docker Hub, GitHub Container Registry, Azure Container Registry) mà VS Code sẽ sử dụng để tạo DevContainer.\n\"mcr.microsoft.com/devcontainers/javascript-node:0-18\"\n\n\ndockerfile\n-\nCho phép sử dụng một Dockerfile tùy chỉnh thay vì tham chiếu đến một hình ảnh.\n\"Dockerfile\"\n\n\ncustomizations\nvscode\nCấu hình các thuộc tính cụ thể cho từng công cụ, chẳng hạn như cài đặt và cấu hình extensions cho VS Code.\n\"customizations\": { \"vscode\": { \"settings\": {}, \"extensions\": [\"streetsidesoftware.code-spell-checker\"] } }\n\n\nsettings\n-\nThêm giá trị mặc định từ settings.json vào một tệp cài đặt riêng biệt dành cho container/máy, chẳng hạn như \"terminal.integrated.defaultProfile.linux\": \"bash\".\n\"settings\": { \"terminal.integrated.defaultProfile.linux\": \"bash\" }\n\n\nextensions\n-\nMột mảng các ID của extensions cần được cài đặt bên trong container khi nó được tạo.\n\"extensions\": [\"streetsidesoftware.code-spell-checker\"]\n\n\nforwardPorts\n-\nLiệt kê các cổng bên trong container mà bạn muốn sẵn sàng ở cổng cục bộ.\n\"forwardPorts\": [3000]\n\n\nportsAttributes\n-\nĐặt các thuộc tính mặc định cho các cổng được chuyển tiếp cụ thể.\n\"portsAttributes\": { \"3000\": { \"label\": \"Hello Remote World\", \"onAutoForward\": \"notify\" } }\n\n\npostCreateCommand\n-\nMột chuỗi lệnh hoặc danh sách đối số lệnh để chạy sau khi container được tạo.\n\"postCreateCommand\": \"yarn install\"\n\n\nremoteUser\n-\nGhi đè người dùng mà VS Code chạy như trong container (cùng với các tiến trình con). Mặc định là containerUser.\n\"remoteUser\": \"root\"\n\n\nfeatures\n-\nMột đối tượng chứa các tính năng cụ thể của Dev Container để thêm vào.\n\"features\": { \"my-feature\": true }\n\n\nbuild\ndockerfile, context\nĐối tượng mô tả cách xây dựng Dev Container từ Dockerfile hoặc Docker Compose.\n\"build\": { \"dockerfile\": \"Dockerfile\", \"context\": \"..\" }\n\n\nrunArgs\n-\nMảng các đối số thêm vào lệnh docker run khi khởi chạy container.\n\"runArgs\": [\"--user\", \"1000:1000\"]\n\n\npostCreateCommand\n-\nMột chuỗi lệnh hoặc danh sách đối số lệnh để chạy sau khi container được tạo.\n\"postCreateCommand\": \"yarn install\"\n\n\nshutdownAction\nstopContainer, none\nHành động mà VS Code sẽ thực hiện khi bạn đóng một cửa sổ hoặc tab trong đó Dev Container đang chạy.\n\"shutdownAction\": \"stopContainer\"\n\n\noverrideCommand\n-\nMột lệnh hoặc danh sách đối số lệnh để thay thế lệnh mặc định khi khởi chạy container.\n\"overrideCommand\": \"npm start\"\n\n\nremoteUser\n-\nGhi đè người dùng mà VS Code chạy như trong container (cùng với các tiến trình con). Mặc định là containerUser.\n\"remoteUser\": \"root\"\n\n\nworkspaceFolder\n/workspace\nĐường dẫn trong container mà mọi hoạt động của VS Code sẽ được thực hiện trong đó.\n\"workspaceFolder\": \"/workspace\"\n\n\nworkspaceMount\n-\nCấu hình mount của thư mục workspace từ máy host vào container.\n\n\n\n\nChú Ý: - Mỗi tùy chọn cụ thể của thuộc tính được liệt kê trong cột “Tùy Chọn” của bảng. - Các giải thích chi tiết cung cấp hiểu biết về mục đích và cách sử dụng mỗi tùy chọn cụ thể. - Các ví dụ minh họa giúp làm rõ cách áp dụng mỗi tùy chọn trong một ngữ cảnh thực tế.\n\n\n\n\n\n\nvscode:\n\nsettings: Cấu hình settings.json cho VS Code bên trong container.\n\nVí Dụ: { \"settings\": { \"python.linting.enabled\": true } }\n\nextensions: Danh sách các extension ID cần cài đặt trong VS Code.\n\nVí Dụ: [\"ms-python.python\"]\n\n\n\n\n\n\n\n&lt;setting&gt;: Các thuộc tính cụ thể của settings.json.\n\nVí Dụ: { \"terminal.integrated.defaultProfile.linux\": \"bash\" }\n\n\n\n\n\n\n&lt;extension&gt;: ID của extension cần được cài đặt.\n\nVí Dụ: [\"streetsidesoftware.code-spell-checker\"]\n\n\n\n\n\n\n&lt;port&gt;: Cổng bên trong container mà bạn muốn sẵn sàng ở cổng cục bộ.\n\nVí Dụ: [3000, 5000]\n\n\n\n\n\n\n&lt;port&gt;:\n\nlabel: Nhãn mô tả cho cổng được chuyển tiếp.\n\nVí Dụ: \"Hello Remote World\"\n\nonAutoForward: Hành động khi cổng được chuyển tiếp tự động (notify/silent).\n\nVí Dụ: \"notify\"\n\n\n\n\n\n\n\n&lt;command&gt;: Chuỗi lệnh hoặc danh sách đối số lệnh để chạy sau khi container được tạo.\n\nVí Dụ: \"yarn install\"\n\n\n\n\n\n\nGiải Thích Ngắn Gọn: - Xác định tên dự án cho Docker Compose giúp phân biệt giữa các tài nguyên được tạo bởi cùng một file docker-compose.yml khi chúng chia sẻ không gian tên.\nVí Dụ:\ndocker-compose -p myproject up -d\n\n\n\nGiải Thích Ngắn Gọn: - Liên kết nhiều container cho phép chúng giao tiếp và làm việc cùng nhau, tạo ra một môi trường ứng dụng phức tạp với nhiều thành phần.\nVí Dụ:\nservices:\n  web:\n    image: nginx\n  api:\n    image: myapi\n  database:\n    image: postgres\n\n\n\nGiải Thích Ngắn Gọn: - Cấu hình các container riêng lẻ cho phép định rõ các thiết lập đặc biệt cho từng dịch vụ, giảm sự phụ thuộc giữa chúng.\nVí Dụ:\nservices:\n  web:\n    image: nginx\n    ports:\n      - \"80:80\"\n  api:\n    image: myapi\n    environment:\n      - DATABASE_URL=mydatabase\n  database:\n    image: postgres\n    volumes:\n      - ./data:/var/lib/postgresql/data\n\n\n\nGiải Thích Ngắn Gọn: - Phát triển trên một Docker host từ xa giúp lập trình viên làm việc trên môi trường mô phỏng, giả lập môi trường sản xuất một cách chính xác.\nVí Dụ:\ndocker-compose -H ssh://user@remote-host up -d\n\n\n\nversion: '3'\n\nservices:\n  frontend:\n    image: frontend\n    networks:\n      - mynetwork\n  backend:\n    image: backend\n    networks:\n      - mynetwork\n  database:\n    image: postgres\n    networks:\n      - mynetwork\n    volumes:\n      - ./data:/var/lib/postgresql/data\n\nnetworks:\n  mynetwork:\n\nDự án Docker Compose có tên là “myproject”.\nKết nối ba container (frontend, backend, database) trên một mạng có tên “mynetwork”.\nMỗi container có cấu hình riêng với cổng, biến môi trường, và thư mục dữ liệu.\nDự án cho phép phát triển cả ba container trên một Docker host từ xa nếu cần thiết."
  },
  {
    "objectID": "posts/docker-tutorial/index.html#dockerfile-và-các-lệnh-phổ-biến",
    "href": "posts/docker-tutorial/index.html#dockerfile-và-các-lệnh-phổ-biến",
    "title": "Docker Tutorial",
    "section": "",
    "text": "Dockerfile là một tệp văn bản chứa một loạt các lệnh, mỗi lệnh đại diện cho một bước trong quá trình xây dựng một hình ảnh Docker. Nó mô tả cách một hình ảnh nên được xây dựng từ các thành phần khác nhau và cài đặt các phần mềm cần thiết.\n\n\n\n\n\n\n\n\n\n\n\nLệnh\nMô Tả\nVí Dụ\n\n\n\n\nFROM\nChọn hình ảnh cơ sở để bắt đầu xây dựng.\nFROM ubuntu:latest\n\n\nCOPY\nSao chép các tệp từ máy host vào hình ảnh.\nCOPY app.py /app/\n\n\nADD\nSao chép các tệp từ máy host hoặc URL vào hình ảnh.\nADD https://example.com/file.txt /app/\n\n\nRUN\nThực hiện các lệnh trong môi trường hình ảnh và tạo lớp mới.\nRUN apt-get update && apt-get install -y curl\n\n\nWORKDIR\nĐặt thư mục làm việc cho các lệnh sau đó.\nWORKDIR /app\n\n\nEXPOSE\nMô tả các cổng mà ứng dụng sẽ lắng nghe khi chạy.\nEXPOSE 80/tcp\n\n\nENV\nĐặt các biến môi trường cho hình ảnh.\nENV NODE_ENV production\n\n\nCMD hoặc ENTRYPOINT\nXác định lệnh mặc định khi container được chạy.\nCMD [\"python\", \"app.py\"]\n\n\nARG\nĐịnh nghĩa các biến mà người dùng có thể truyền vào lúc xây dựng.\nARG version=latest\n\n\nLABEL\nThêm các metadata (nhãn) vào hình ảnh.\nLABEL maintainer=\"admin@example.com\"\n\n\nVOLUME\nChỉ định các thư mục làm thư mục volume và được dùng để lưu trữ dữ liệu.\nVOLUME /data\n\n\nRUN, CMD, ENTRYPOINT\nCác lệnh có thể sử dụng dưới dạng shell hoặc mảng đối số.\nRUN apt-get update && apt-get install -y curl\n\n\n\nLưu Ý: - Một Dockerfile thường bắt đầu bằng lệnh FROM. - Các lệnh được thực thi theo thứ tự từ trên xuống dưới trong Dockerfile. - Có thể kết hợp nhiều lệnh trong một dòng bằng cách sử dụng &&. - Các lệnh CMD và ENTRYPOINT giúp xác định hành động mặc định khi container chạy.\nDockerfile là công cụ quan trọng để xây dựng hình ảnh Docker và tự động hóa quy trình triển khai ứng dụng."
  },
  {
    "objectID": "posts/docker-tutorial/index.html#docker-compose-giải-thích-lệnh-và-thuộc-tính",
    "href": "posts/docker-tutorial/index.html#docker-compose-giải-thích-lệnh-và-thuộc-tính",
    "title": "Docker Tutorial",
    "section": "",
    "text": "Docker Compose là công cụ giúp quản lý và triển khai ứng dụng đa-container trong môi trường Docker. Dưới đây là một bảng tổng hợp các lệnh và thuộc tính quan trọng trong Docker Compose:\n\n\n\n\n\n\n\n\n\n\nLệnh\nThuộc Tính\nKiểu Dữ Liệu\nMô Tả Chi Tiết\nVí Dụ\n\n\n\n\ndocker-compose up\n-\n-\nChạy các dịch vụ được định nghĩa trong file docker-compose.yml.\ndocker-compose up\n\n\ndocker-compose down\n-\n-\nDừng và xóa tất cả các container, mạng và dữ liệu đã tạo.\ndocker-compose down\n\n\ndocker-compose ps\n-\n-\nLiệt kê các container đang chạy.\ndocker-compose ps\n\n\ndocker-compose exec\n-\n-\nThực hiện lệnh bên trong một container.\ndocker-compose exec webserver ls\n\n\ndocker-compose logs\n-\n-\nXem logs của các dịch vụ.\ndocker-compose logs\n\n\ndocker-compose build\n-\n-\nXây dựng lại các images của dịch vụ.\ndocker-compose build\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThuộc Tính\nKiểu Dữ Liệu\nMô Tả Chi Tiết\nVí Dụ\n\n\n\n\nversion\n-\nPhiên bản của Docker Compose.\nversion: '3'\n\n\nservices\n-\nĐịnh nghĩa các dịch vụ, mỗi dịch vụ có các cài đặt riêng.\nservices: web, db\n\n\nimage\n-\nTên hình ảnh của dịch vụ.\nimage: nginx:latest\n\n\nbuild\n-\nXây dựng dịch vụ từ Dockerfile trong thư mục hiện tại hoặc chỉ định.\nbuild: ./web\n\n\nports\n-\nChuyển tiếp cổng giữa máy host và container.\nports: - \"8080:80\"\n\n\nvolumes\n-\nMount thư mục hoặc volume giữa máy host và container.\nvolumes: - ./data:/app/data\n\n\nenvironment\n-\nĐặt biến môi trường cho dịch vụ.\nenvironment: - DEBUG=True\n\n\ndepends_on\n-\nXác định các dịch vụ phụ thuộc cần chạy trước.\ndepends_on: - db\n\n\n\n\n\n\nversion: '3'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - \"8080:80\"\n    volumes:\n      - ./web:/app\n    environment:\n      - DEBUG=True\n  db:\n    image: postgres:latest\n    volumes:\n      - /var/lib/postgresql/data\n    environment:\n      - POSTGRES_PASSWORD=mysecretpassword\n\nĐịnh nghĩa hai dịch vụ: web (nginx) và db (PostgreSQL).\nDịch vụ web sử dụng hình ảnh nginx, chuyển tiếp cổng 8080 từ máy host vào cổng 80 của container, mount thư mục ./web vào /app, và đặt biến môi trường DEBUG là True.\nDịch vụ db sử dụng hình ảnh PostgreSQL, mount thư mục dữ liệu vào /var/lib/postgresql/data, và đặt mật khẩu PostgreSQL."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Chào mừng ghé thăm blog của Kiên, đây là bài đăng đầu tiên"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "SQL Tutorial\n\n\n\n\n\n\ntutorial\n\n\ncode\n\n\nnotebook\n\n\n\n\n\n\n\n\n\nDec 7, 2023\n\n\nKevil Nguyen\n\n\n\n\n\n\n\n\n\n\n\n\nDocker Tutorial\n\n\n\n\n\n\ntutorial\n\n\ncode\n\n\nnotebook\n\n\n\n\n\n\n\n\n\nDec 7, 2023\n\n\nKevil Nguyen\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nDec 4, 2023\n\n\nKevil Nguyen\n\n\n\n\n\n\n\n\n\n\n\n\nMy Rust Book\n\n\n\n\n\n\ntutorial\n\n\ncode\n\n\nnotebook\n\n\n\n\n\n\n\n\n\nFeb 28, 2022\n\n\nKevil Nguyen\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/my-rust-book/index.html",
    "href": "posts/my-rust-book/index.html",
    "title": "My Rust Book",
    "section": "",
    "text": "Blog này sẽ tổng hợp lại những kiến thức và từ khoá quan trọng trong ngôn ngữ Rust\n\n\nBảng tổng hợp:\n\n\n\n\n\n\n\n\n\nChủ đề\nTóm tắt\nTừ khóa\nVí dụ\n\n\n\n\nBiến\nLưu trữ giá trị\nlet, mut\nlet x = 5;\n\n\nTính bất biến\nGiá trị không thể thay đổi sau khi gán\nlet\nlet x = 5; // x = 6 sẽ gây lỗi\n\n\nTính biến đổi\nGiá trị có thể thay đổi sau khi gán\nmut\nlet mut x = 5; x = 6;\n\n\nHằng\nGiá trị bất biến, được đặt tên\nconst\nconst PI: f32 = 3.14159;\n\n\nBóng biến\nTạo biến mới với cùng tên trong phạm vi\nlet\nlet x = 5; let x = x + 1;\n\n\n\nSo sánh với Python/C#:\n\nPython và C# sử dụng garbage collection để quản lý bộ nhớ, trong khi Rust sử dụng ownership để đảm bảo an toàn bộ nhớ và tránh lỗi memory leak.\nRust khuyến khích sử dụng tính bất biến theo mặc định để đơn giản hóa code và tránh lỗi, nhưng vẫn cho phép sử dụng tính biến đổi khi cần thiết.\n\nƯu nhược điểm:\n\nTính bất biến:\n\nƯu điểm: An toàn bộ nhớ, dễ hiểu, tránh lỗi.\nNhược điểm: Khó quen hơn so với ngôn ngữ có garbage collection.\n\nTính biến đổi:\n\nƯu điểm: Linh hoạt hơn trong một số trường hợp.\nNhược điểm: Cần chú ý để tránh lỗi và phức tạp hóa code.\n\n\nỨng dụng:\n\nHằng: Lưu trữ các giá trị cố định như PI, tốc độ ánh sáng.\nBiến bất biến: Lưu trữ các giá trị không cần thay đổi, đơn giản hóa code.\nBiến biến đổi: Lưu trữ các giá trị cần thay đổi trong quá trình thực thi.\nBóng biến: Tạo biến cục bộ với cùng tên, giúp tránh xung đột tên.\n\nKết luận:\nRust cung cấp các tính năng về biến và tính bất biến giúp viết code an toàn, hiệu quả và dễ hiểu. Hiểu rõ các khái niệm này là nền tảng quan trọng để học tập và làm việc với Rust.\n\n\n\nĐiểm chính:\n\nMọi giá trị trong Rust đều có kiểu dữ liệu. Điều này cho trình biên dịch biết loại dữ liệu nào nó đang làm việc và cho phép đảm bảo an toàn kiểu.\nRust là ngôn ngữ có kiểu dữ liệu tĩnh, nghĩa là trình biên dịch phải biết kiểu của tất cả các biến tại thời điểm biên dịch.\nKiểu dữ liệu có thể được chia thành hai loại: kiểu đơn giản và kiểu phức tạp.\n\nKiểu đơn giản:\n\nBiểu thị các giá trị đơn lẻ.\nBốn kiểu chính:\n\nSố nguyên: Biểu thị số nguyên (ví dụ: i32, u64).\nSố thực: Biểu thị số có phần thập phân (ví dụ: f32, f64).\nBoolean: Biểu thị giá trị true hoặc false (bool).\nKý tự: Biểu thị ký tự đơn lẻ (char).\n\n\nKiểu phức tạp:\n\nNhóm nhiều giá trị thành một đơn vị.\nHai kiểu cơ bản:\n\nTuple: Các bộ sưu tập có thứ tự, độ dài cố định của các giá trị có thể có kiểu khác nhau (ví dụ: (500, 6.4, 1)).\nMảng: Các bộ sưu tập có độ dài cố định của các giá trị có cùng kiểu (ví dụ: [1, 2, 3, 4, 5]).\n\n\nGhi chú bổ sung:\n\nRust áp dụng an toàn kiểu, giúp ngăn chặn lỗi bộ nhớ.\nTràn số nguyên có thể xảy ra nếu phép toán vượt quá phạm vi của kiểu đã chọn.\nMảng hữu ích cho dữ liệu có kích thước cố định trên ngăn xếp, trong khi vectơ (được thảo luận trong Chương 8) linh hoạt hơn và có thể tăng hoặc giảm kích thước.\n\nTóm lại, hiểu rõ kiểu dữ liệu là điều cần thiết để viết mã Rust chính xác và hiệu quả.\n\n\n\nChức năng đóng vai trò là những viên gạch thiết yếu trong Rust, đóng gói các nhiệm vụ hoặc phép toán cụ thể. Chúng cho phép bạn cấu trúc mã hiệu quả, thúc đẩy tái sử dụng mã, đồng thời nâng cao khả năng đọc và bảo trì.\nKhái niệm chính:\n\nĐịnh nghĩa Chức năng:\n\nSử dụng từ khóa fn, tiếp theo là tên chức năng và dấu ngoặc đơn cho các tham số.\nDấu ngoặc nhọn {} bao quanh phần thân chức năng chứa mã được thực thi.\n\nChữ ký Chức năng:\n\nBao gồm tên chức năng, danh sách tham số (nếu có) và kiểu trả về (tùy chọn).\nVí dụ: fn plus_one(x: i32) -&gt; i32\n\nplus_one: Tên chức năng\nx: i32: Tham số tên x có kiểu i32 (số nguyên)\n-&gt; i32: Trả về giá trị i32\n\n\nTham số và Đối số:\n\nTham số là các biến được định nghĩa trong chữ ký chức năng.\nĐối số là các giá trị thực tế được truyền khi gọi chức năng.\nVí dụ: plus_one(5) truyền đối số 5 cho tham số x.\n\nGiá trị Trả về:\n\nChức năng có thể tùy chọn trả về giá trị bằng cách sử dụng từ khóa return hoặc ngầm định thông qua biểu thức cuối cùng.\nKiểu trả về phải được chỉ định sau mũi tên -&gt; trong chữ ký.\n\n\nVí dụ: Cộng hai số\nfn add(x: i32, y: i32) -&gt; i32 {\n    x + y\n}\n\nfn main() {\n    let sum = add(5, 3); // Gọi hàm add với các đối số 5 và 3\n    println!(\"Tổng là: {}\", sum);\n}\nGiải thích:\n\nHàm add lấy hai tham số i32 (x và y) và trả về giá trị i32.\nBên trong hàm, x và y được cộng lại và kết quả được trả về.\nTrong hàm main, add được gọi với các đối số 5 và 3, gán tổng trả về cho biến sum.\nGiá trị của sum được in ra bằng println!.\n\nGọi Chức năng:\n\nĐể gọi một chức năng, hãy sử dụng tên của nó theo sau là dấu ngoặc đơn chứa các đối số theo đúng thứ tự và kiểu.\nĐối số được đánh giá trước khi được truyền cho chức năng.\n\nLợi ích của việc sử dụng Chức năng:\n\nTái sử dụng Mã: Định nghĩa một chức năng một lần và gọi nó từ nhiều vị trí trong mã của bạn.\nKhả năng đọc được cải thiện: Chia nhỏ các khối mã lớn thành các chức năng nhỏ hơn được đặt tên tốt, giúp mã dễ hiểu hơn.\nKhả năng bảo trì: Việc sửa đổi dễ dàng hơn khi mã được tổ chức thành các chức năng, vì các thay đổi chỉ ảnh hưởng đến chức năng liên quan.\n\nLưu ý bổ sung:\n\nChức năng có thể có từ 0 đến nhiều tham số và một giá trị trả về duy nhất.\nChức năng có thể được định nghĩa bất cứ nơi nào trong mã của bạn, nhưng phải có thể truy cập được từ nơi chúng được gọi.\nRust áp dụng an toàn kiểu, đảm bảo tính tương thích kiểu giữa các tham số, đối số và giá trị trả về.\n\n\n\n\nMục đích:\nGiống như nhiều ngôn ngữ lập trình khác, Rust cho phép lập trình viên thêm các bình luận (comment) vào mã nguồn. Bình luận là những đoạn văn bản nhằm giải thích hoặc ghi chú về mã nguồn, nhưng sẽ bị trình biên dịch Rust bỏ qua. Bình luận giúp cho người đọc mã nguồn dễ dàng hiểu được logic và mục đích của từng phần code.\nKiểu bình luận:\nRust hỗ trợ hai loại bình luận chính:\n\nBình luận dòng (line comment): Bắt đầu bằng hai dấu gạch chéo // và kéo dài đến hết dòng.\nBình luận khối (block comment): Bắt đầu bằng /* và kết thúc bằng */. Bình luận khối có thể kéo dài nhiều dòng.\n\nVí dụ:\n// Bình luận dòng\nlet x = 5; // Gán giá trị 5 cho biến x\n\n/* Bình luận khối\n   Giải thích về đoạn code tiếp theo\n*/\nlet y = x * 2;\nVị trí:\nBình luận có thể được đặt ở nhiều vị trí khác nhau trong mã nguồn:\n\nTrước một dòng code để giải thích mục đích của dòng đó.\nSau một dòng code để cung cấp thêm thông tin chi tiết.\nGiữa các dòng code để giải thích logic của một khối code phức tạp.\n\nThực hành tốt:\n\nSử dụng bình luận một cách hợp lý, không nên lạm dụng quá nhiều.\nGiữ cho bình luận ngắn gọn và dễ hiểu, tránh sử dụng ngôn ngữ khó hiểu hoặc thuật ngữ chuyên ngành trừ khi cần thiết.\nCập nhật bình luận khi code thay đổi để đảm bảo tính nhất quán.\n\nBằng việc sử dụng bình luận hiệu quả, bạn có thể cải thiện đáng kể tính dễ đọc và bảo trì của mã nguồn Rust, giúp cho người khác (và chính bạn trong tương lai) dễ dàng hiểu được logic và mục đích của code.\n\n\n\nKhái niệm:\nKiểm soát luồng là khả năng thực thi các khối mã khác nhau tùy theo điều kiện và lặp lại một khối mã nhiều lần cho đến khi một điều kiện nào đó được đáp ứng. Trong Rust, các công cụ chính để kiểm soát luồng là biểu thức if và vòng lặp.\nBiểu thức if:\n\nCho phép rẽ nhánh mã theo các điều kiện.\nCú pháp:\nif condition {\n    // Khối mã được thực thi nếu điều kiện là đúng\n} else {\n    // Khối mã được thực thi nếu điều kiện là sai (tùy chọn)\n}\ncondition phải là một biểu thức trả về giá trị bool.\nVí dụ:\nlet number = 3;\n\nif number &lt; 5 {\n    println!(\"Điều kiện là đúng\");\n} else {\n    println!(\"Điều kiện là sai\");\n}\n\nVòng lặp:\n\nCho phép lặp lại một khối mã nhiều lần.\nRust có 3 loại vòng lặp: loop, while, và for.\n\n1. Vòng lặp loop:\n\nLặp lại vô tận cho đến khi sử dụng lệnh break để thoát.\nVí dụ:\nloop {\n    println!(\"Lặp lại!\");\n    break; // Thoát khỏi vòng lặp\n}\n\n2. Vòng lặp while:\n\nLặp lại cho đến khi một điều kiện trở thành false.\nCú pháp:\nwhile condition {\n    // Khối mã được thực thi\n}\nVí dụ:\nlet mut number = 3;\n\nwhile number != 0 {\n    println!(\"{}\", number);\n    number -= 1;\n}\n\n3. Vòng lặp for:\n\nLặp lại từng phần tử trong một bộ sưu tập (mảng, danh sách, …).\nCú pháp:\nfor element in collection {\n    // Khối mã được thực thi cho mỗi phần tử\n}\nVí dụ:\nlet numbers = [1, 2, 3, 4, 5];\n\nfor number in numbers {\n    println!(\"Giá trị: {}\", number);\n}\n\nTóm lược:\nBiểu thức if và các vòng lặp là công cụ quan trọng để kiểm soát luồng thực thi của chương trình Rust. Việc sử dụng linh hoạt các công cụ này giúp bạn viết code logic và hiệu quả hơn.\n\n\n\nQuyền sở hữu là một khái niệm cốt lõi trong Rust, chi phối cách quản lý và truy cập bộ nhớ trong chương trình của bạn. Nó đảm bảo an toàn bộ nhớ và ngăn chặn các lỗi như rò rỉ bộ nhớ và con trỏ lơ lửng. Dưới đây là phân tích về Quyền sở hữu trong Rust:\n1. Mỗi giá trị trong Rust có một chủ sở hữu (Owner). - Chủ sở hữu này là biến giữ giá trị. - Chỉ có một biến có thể sở hữu một giá trị tại một thời điểm.\n2. Khi chủ sở hữu đi ra khỏi phạm vi, giá trị sẽ bị hủy (drop). - Phạm vi xác định khối mã nơi một biến hợp lệ. - Khi khối mã kết thúc, biến sẽ đi ra khỏi phạm vi và giá trị sở hữu của nó sẽ tự động bị hủy (giải phóng khỏi bộ nhớ).\n3. Có hai cách để tương tác với dữ liệu: di chuyển (move) và sao chép (copy). - Di chuyển: Khi bạn gán một giá trị (như String) cho một biến khác, quyền sở hữu sẽ được chuyển (di chuyển). Biến ban đầu trở nên không hợp lệ và không thể sử dụng được nữa. - Sao chép: Đối với các kiểu dữ liệu đơn giản như số nguyên (i32), có kích thước đã biết và được lưu trữ trên ngăn xếp, việc gán sẽ tạo ra một bản sao của giá trị. Cả hai biến đều hợp lệ và độc lập.\n4. Quyền sở hữu và Hàm: - Việc truyền giá trị cho một hàm thường di chuyển quyền sở hữu, tương tự như việc gán. Hàm trở thành chủ sở hữu mới và giá trị không còn hợp lệ trong phạm vi gọi. - Trả về giá trị từ hàm cũng có thể chuyển quyền sở hữu. Giá trị trả về trở thành sở hữu của phạm vi gọi.\n5. Tham chiếu (References): - Tham chiếu mượn quyền sở hữu của một giá trị mà không chiếm quyền sở hữu chính nó. Chúng cung cấp một cách để truy cập và sử dụng dữ liệu mà không di chuyển nó. - Tham chiếu đặc biệt hữu ích khi bạn muốn nhiều phần trong mã của mình làm việc với cùng một dữ liệu mà không cần sao chép hoặc lo lắng về quyền sở hữu.\nLợi ích của Quyền sở hữu:\n\nAn toàn bộ nhớ: Quyền sở hữu ngăn chặn rò rỉ bộ nhớ và con trỏ lơ lửng, làm cho chương trình Rust đáng tin cậy hơn và ít bị lỗi hơn.\nCải thiện độ rõ ràng của mã: Quy tắc sở hữu thực thi quản lý dữ liệu rõ ràng, dẫn đến hành vi mã rõ ràng hơn và dễ dự đoán hơn.\nHiệu quả: Quyền sở hữu loại bỏ nhu cầu quản lý bộ nhớ thủ công (như trong C/C++), có khả năng cải thiện hiệu suất bằng cách tránh các hoạt động bộ nhớ không cần thiết.\n\nGhi chú bổ sung:\n\nHàm drop được tự động gọi khi một giá trị bị hủy, cho phép thực hiện bất kỳ hành động dọn dẹp nào cần thiết.\nĐặc điểm Copy được triển khai cho các kiểu đơn giản như số nguyên, cho biết chúng có thể được sao chép mà không ảnh hưởng đến giá trị ban đầu.\nHiểu rõ về Quyền sở hữu là điều cần thiết để viết chương trình Rust hiệu quả và an toàn.\n\nBằng cách nắm vững các nguyên tắc sở hữu này, bạn sẽ có thể phát triển các ứng dụng Rust mạnh mẽ và đáng tin cậy.\n\n\n\nVấn đề với mã tuple trong Liệt kê 4-5 là chúng ta phải trả về giá trị String cho hàm gọi để vẫn có thể sử dụng String sau khi gọi calculate_length, vì String đã được di chuyển vào calculate_length. Thay vào đó, chúng ta có thể cung cấp một tham chiếu (reference) tới giá trị String. Tham chiếu giống như một con trỏ ở chỗ nó là một địa chỉ mà chúng ta có thể theo dõi để truy cập dữ liệu được lưu trữ tại địa chỉ đó; dữ liệu đó thuộc sở hữu của một biến khác. Không giống như con trỏ, tham chiếu được đảm bảo sẽ trỏ đến một giá trị hợp lệ của một kiểu dữ liệu cụ thể trong suốt vòng đời của tham chiếu đó.\nĐây là cách bạn định nghĩa và sử dụng hàm calculate_length có tham chiếu đến một đối tượng làm tham số thay vì lấy quyền sở hữu giá trị:\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -&gt; usize {\n    s.len()\n}\nĐầu tiên, lưu ý rằng tất cả mã tuple trong khai báo biến và giá trị trả về của hàm đã biến mất. Thứ hai, lưu ý rằng chúng ta truyền &s1 vào calculate_length và trong định nghĩa của nó, chúng ta lấy &String thay vì String. Những dấu ngoặc nhọn này biểu thị tham chiếu (references), và chúng cho phép bạn tham chiếu đến một giá trị nào đó mà không chiếm quyền sở hữu nó. Hình 4-5 mô tả khái niệm này.\n[Hình 4-5: Sơ đồ của &String s trỏ đến String s1]\nLưu ý: Phép toán ngược lại của việc tham chiếu bằng cách sử dụng & là hủy tham chiếu (dereferencing), được thực hiện bằng toán tử hủy tham chiếu, *. Chúng ta sẽ thấy một số cách sử dụng toán tử hủy tham chiếu trong Chương 8 và thảo luận chi tiết về hủy tham chiếu trong Chương 15.\nHãy xem xét kỹ hơn lời gọi hàm ở đây:\nlet s1 = String::from(\"hello\");\n\nlet len = calculate_length(&s1);\nCú pháp &s1 cho phép chúng ta tạo một tham chiếu tham chiếu đến giá trị của s1 nhưng không sở hữu nó. Vì nó không sở hữu nó, giá trị mà nó trỏ đến sẽ không bị hủy khi tham chiếu ngừng được sử dụng.\nTương tự, chữ ký của hàm sử dụng & để chỉ ra rằng kiểu của tham số s là một tham chiếu. Hãy thêm một số chú thích giải thích:\nfn calculate_length(s: &String) -&gt; usize { // s là một tham chiếu đến một String\n    s.len()\n} // Tại đây, s ra khỏi phạm vi. Nhưng vì nó không sở hữu những gì nó tham chiếu đến, nên nó không bị hủy.\nPhạm vi mà biến s hợp lệ giống như bất kỳ phạm vi nào của tham số hàm, nhưng giá trị được tham chiếu bởi tham chiếu không bị hủy khi s ngừng được sử dụng, bởi vì s không sở hữu. Khi các hàm có tham chiếu làm tham số thay vì các giá trị thực tế, chúng ta sẽ không cần trả về các giá trị để trả lại quyền sở hữu, vì chúng ta chưa bao giờ có quyền sở hữu.\nChúng ta gọi hành động tạo ra một tham chiếu là mượn (borrowing). Giống như trong cuộc sống thực, nếu ai đó sở hữu thứ gì, bạn có thể mượn nó từ họ. Khi bạn xong việc, bạn phải trả lại. Bạn không sở hữu nó.\nVậy, chuyện gì xảy ra nếu chúng ta cố gắng sửa đổi thứ gì đó mà chúng ta đang mượn? Thử mã trong Liệt kê 4-6. Cảnh báo Spoiler: nó không hoạt động!\nfn main() {\n    let s = String::from(\"hello\");\n\n    change(&s);\n}\n\nfn change(some_string: &String) {\n    some_string.push_str(\", world\");\n}\nĐây là lỗi:\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0596]: cannot borrow `*some_string` as\n\n\n\nString Slices là gì?\nTrong Rust, String Slices là kiểu dữ liệu cơ bản cho phép bạn tham chiếu một chuỗi ký tự liên tục trong một String. Về bản chất, chúng là các tham chiếu được mượn từ một phần của String, cho phép bạn làm việc với các phần cụ thể của chuỗi mà không cần sở hữu toàn bộ chuỗi.\nTại sao nên sử dụng String Slices?\nString Slices mang lại nhiều lợi ích:\n\nHiệu quả sử dụng bộ nhớ: Tránh sao chép dữ liệu không cần thiết. Thay vì tạo một chuỗi mới cho mỗi thao tác con chuỗi, bạn có thể sử dụng một slice để truy cập trực tiếp vào phần liên quan của chuỗi gốc. Điều này đặc biệt hữu ích khi xử lý các chuỗi lớn.\nLập trình chức năng: Slices tích hợp liền mạch với các cấu trúc lập trình chức năng của Rust như iterators và closures, cung cấp cách ngắn gọn và biểu cảm để thao tác với chuỗi.\nMượn và Tham chiếu: Tuân theo các quy tắc sở hữu và mượn của Rust, đảm bảo an toàn bộ nhớ và ngăn chặn các con trỏ lơ lửng.\n\nTạo String Slices\nBạn có thể tạo String Slices theo hai cách:\n\nSử dụng String Literals: String literals (được biểu thị bằng dấu ngoặc kép \") tự động được chuyển đổi thành &str string slices, là các tham chiếu không thay đổi đến dữ liệu chuỗi được lưu trữ trong nhị phân của chương trình.\nlet hello_world = \"Hello, world!\";\nlet hello = &hello_world[0..5]; // Slice từ chỉ mục 0 (bao gồm) đến 5 (không bao gồm)\nCắt một String: Bạn có thể tạo một slice của một String bằng cách sử dụng cú pháp lập chỉ mục [start_index..end_index]. start_index (bao gồm) chỉ định ký tự bắt đầu và end_index (không bao gồm) chỉ định ký tự sau ký tự cuối cùng được bao gồm trong slice.\nlet mut my_string = String::from(\"Rust is awesome!\");\nlet awesome = &my_string[11..];  // Slice từ chỉ mục 11 (bao gồm) đến cuối\n\nCú pháp cắt phổ biến:\n\n[start_index..end_index]: Đây là cú pháp chung, trong đó start_index và end_index là các biểu thức số nguyên cho biết vị trí bắt đầu và kết thúc của slice (không bao gồm end_index).\n[..end_index]: Bao gồm tất cả các ký tự từ đầu chuỗi đến, nhưng không bao gồm, end_index.\n[start_index..]: Bao gồm tất cả các ký tự từ start_index (bao gồm) đến cuối chuỗi.\n[:]: Bao gồm toàn bộ chuỗi (tương đương với [..).\n\nĐiểm chính cần ghi nhớ:\n\nString Slices không thay đổi; bạn không thể sửa đổi trực tiếp các ký tự bên trong chúng.\nString Slices mượn từ chuỗi gốc, vì vậy thời gian tồn tại của chúng gắn liền với thời gian tồn tại của chuỗi gốc.\nString Slices nhẹ và không yêu cầu phân bổ bộ nhớ bổ sung trong hầu hết các trường hợp.\n\nLưu ý bổ sung:\n\nKhi làm việc với string slices chứa văn bản được mã hóa UTF-8, hãy đảm bảo rằng ranh giới slice của bạn căn chỉnh với ranh giới ký tự UTF-8 hợp lệ. Nếu không, bạn có thể gặp lỗi.\nString Slices cung cấp một số phương thức để thao tác chuỗi, chẳng hạn như iter(), len() và is_empty(). Các phương thức này hoạt động trên dữ liệu được mượn và không sửa đổi chuỗi gốc.\n\nTóm lại\nString Slices là một công cụ mạnh mẽ và linh hoạt trong Rust để làm việc với các phần cụ thể của chuỗi. Chúng thúc đẩy hiệu quả sử dụng bộ nhớ, tạo điều kiện cho lập trình chức năng và tuân theo các hệ thống sở hữu và mượn của Rust. Bằng cách hiểu cách tạo, cú pháp phổ biến và các điểm chính, bạn có thể sử dụng String Slices hiệu quả trong các chương trình Rust của mìnhepj\n\n\n\nVí dụ về Struct:\nNgoài ví dụ về User đã được đề cập, đây là một số ví dụ khác về cách sử dụng struct:\n\nStruct để biểu diễn điểm trong không gian 3 chiều:\n\nstruct Point3D {\n    x: f64,\n    y: f64,\n    z: f64,\n}\n\nStruct để biểu diễn ngày tháng:\n\nstruct Date {\n    year: u32,\n    month: u8,\n    day: u8,\n}\n\nStruct để biểu diễn một bộ bài:\n\nstruct Card {\n    suit: Suit,\n    rank: Rank,\n}\n\nenum Suit {\n    Hearts,\n    Diamonds,\n    Clubs,\n    Spades,\n}\n\nenum Rank {\n    Ace,\n    Two,\n    Three,\n    ...\n    Ten,\n    Jack,\n    Queen,\n    King,\n}\nSử dụng Struct với các hàm:\nBạn có thể sử dụng struct với các hàm để truyền dữ liệu một cách hiệu quả và dễ đọc. Ví dụ:\nfn greet_user(user: User) {\n    println!(\"Hello, {}!\", user.username);\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n\n    greet_user(user1);\n}\nLợi ích của việc sử dụng Struct:\n\nKhả năng đọc: Struct giúp mã của bạn dễ đọc và dễ hiểu hơn bằng cách nhóm các dữ liệu liên quan lại với nhau.\nTính bảo trì: Struct giúp mã của bạn dễ bảo trì hơn bằng cách cho phép bạn dễ dàng thêm, xóa hoặc sửa đổi các trường.\nTái sử dụng: Bạn có thể sử dụng lại struct trong các phần khác nhau của mã.\n\nKết luận:\nStruct là một công cụ mạnh mẽ trong Rust cho phép bạn nhóm các dữ liệu liên quan lại với nhau và tạo ra các kiểu dữ liệu tùy chỉnh. Sử dụng struct có thể giúp mã của bạn dễ đọc, dễ bảo trì và dễ sử dụng lại.\nNgoài ra:\n\nBạn có thể sử dụng các thuộc tính để thêm metadata vào các struct và trường của chúng.\nBạn có thể sử dụng các phương thức để thêm chức năng vào struct.\nBạn có thể sử dụng các trait để cung cấp chức năng chung cho các struct khác nhau.\n\n\n\n\nĐể hiểu khi nào chúng ta có thể sử dụng struct, hãy viết một chương trình tính toán diện tích hình chữ nhật. Chúng ta sẽ bắt đầu bằng cách sử dụng các biến đơn, sau đó cải tiến chương trình cho đến khi sử dụng struct.\nGiả sử chúng ta tạo một dự án nhị phân mới với Cargo có tên là rectangles, dự án này sẽ lấy chiều rộng và chiều cao của một hình chữ nhật được xác định bằng pixel và tính toán diện tích của hình chữ nhật. Liệt kê 5-8 hiển thị một chương trình ngắn thực hiện chính xác việc đó trong thư mục src/main.rs của dự án.\nfn main() {\n    let width1 = 30;\n    let height1 = 50;\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(width1, height1)\n    );\n}\n\nfn area(width: u32, height: u32) -&gt; u32 {\n    width * height\n}\nBảng 5-8: Tính toán diện tích của một hình chữ nhật được xác định bởi các biến riêng biệt về chiều rộng và chiều cao\nBây giờ, hãy chạy chương trình này bằng cách sử dụng cargo run:\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running `target/debug/rectangles`\nThe area of the rectangle is 1500 square pixels.\nMã này thành công trong việc tìm ra diện tích của hình chữ nhật bằng cách gọi hàm area với mỗi chiều, nhưng chúng ta có thể làm nhiều hơn để mã này rõ ràng và dễ đọc hơn.\nVấn đề với đoạn mã này nằm ở phần khai báo hàm area:\nfn area(width: u32, height: u32) -&gt; u32 {\nHàm area được cho là để tính toán diện tích của một hình chữ nhật, nhưng hàm chúng ta viết có hai tham số và không rõ ràng ở bất kỳ đâu trong chương trình của chúng ta rằng các tham số này có liên quan. Sẽ dễ đọc và dễ quản lý hơn nếu nhóm chiều rộng và chiều cao lại với nhau. Chúng ta đã thảo luận về một cách thực hiện việc đó trong phần “Kiểu Tuple” của Chương 3: bằng cách sử dụng tuple.\nCải tiến với Tuple\nLiệt kê 5-9 hiển thị một phiên bản khác của chương trình của chúng ta sử dụng tuple.\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -&gt; u32 {\n    dimensions.0 * dimensions.1\n}\nBảng 5-9: Xác định chiều rộng và chiều cao của hình chữ nhật bằng một tuple\nTheo một cách nào đó, chương trình này tốt hơn. Tuple cho phép chúng ta thêm một chút cấu trúc và bây giờ chúng ta chỉ truyền một đối số. Nhưng theo cách khác, phiên bản này kém rõ ràng hơn: tuple không đặt tên cho các phần tử của chúng, vì vậy chúng ta phải lập chỉ mục vào các phần của tuple, khiến phép tính của chúng ta trở nên kém rõ ràng hơn.\nViệc trộn lẫn chiều rộng và chiều cao sẽ không ảnh hưởng đến việc tính toán diện tích, nhưng nếu chúng ta muốn vẽ hình chữ nhật trên màn hình, thì điều đó sẽ quan trọng! Chúng ta phải nhớ rằng width là chỉ mục tuple 0 và height là chỉ mục tuple 1. Điều này thậm chí còn khó hơn đối với người khác để tìm ra và ghi nhớ nếu họ sử dụng mã của chúng ta. Bởi vì chúng tôi chưa truyền đạt ý nghĩa của dữ liệu trong mã của mình, nên bây giờ dễ mắc lỗi hơn.\nCải tiến với Struct: Thêm nhiều ý nghĩa hơn\nChúng ta sử dụng struct để thêm ý nghĩa bằng cách gắn nhãn cho dữ liệu. Chúng ta có thể chuyển đổi tuple đang sử dụng thành một struct có tên cho toàn bộ và tên cho các phần, như được hiển thị trong Liệt kê 5-10.\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n        }\n    }\n\n\n\nDưới đây là tóm tắt các điểm chính về cú pháp phương thức trong Rust:\nGiống với hàm:\n\nPhương thức được khai báo tương tự như hàm, sử dụng từ khóa fn, tên và dấu ngoặc đơn.\nChúng có thể có tham số và giá trị trả về.\nChúng chứa mã được thực thi khi phương thức được gọi.\n\nKhác với hàm:\n\nBối cảnh: Phương thức được định nghĩa trong bối cảnh của một struct (hoặc enum hoặc trait object), không phải trong phạm vi chính.\nTham số đầu tiên: Phương thức có một tham số đặc biệt đầu tiên tên là self. Tham số này đại diện cho thể hiện của struct mà phương thức đang được gọi.\n\nGọi phương thức:\n\nPhương thức được gọi bằng ký hiệu chấm: instance_name.method_name(arguments).\ninstance_name là biến giữ thể hiện struct.\nmethod_name là tên của phương thức bạn muốn gọi.\narguments là bất kỳ giá trị nào được truyền cho phương thức dưới dạng đầu vào.\n\nMượn:\n\nPhương thức có thể chỉ định cách chúng mượn tham số self:\n\n&self: Mượn thể hiện không thay đổi (chỉ đọc).\n&mut self: Mượn thể hiện có thể thay đổi (đọc-ghi).\nself: Tiếp quản quyền sở hữu của thể hiện (hiếm khi sử dụng).\n\n\nVí dụ:\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -&gt; u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle { width: 30, height: 50 };\n    let area = rect1.area(); // Gọi phương thức area\n    println!(\"Diện tích hình chữ nhật là {} pixel vuông.\", area);\n}\nGiải thích:\n\nRectangle là một struct định nghĩa hai trường: width và height.\nimpl Rectangle { ... } định nghĩa các phương thức liên quan đến struct Rectangle.\narea(&self) là một phương thức tính diện tích hình chữ nhật. Nó mượn thể hiện (&self) không thay đổi.\nrect1.area() gọi phương thức area trên thể hiện rect1.\n\n\n\n\nVí dụ thực tế:\nGiả sử bạn đang xây dựng một ứng dụng quản lý thư viện. Bạn cần lưu trữ thông tin về sách, bao gồm tiêu đề, tác giả, ngày xuất bản và ISBN. Bạn có thể sử dụng một struct để biểu diễn thông tin này:\nstruct Book {\n    title: String,\n    author: String,\n    published_date: String,\n    isbn: String,\n}\nTuy nhiên, struct này không thể biểu diễn trường hợp sách không có ISBN. Để giải quyết vấn đề này, bạn có thể sử dụng enum Option&lt;T&gt;:\nenum BookInfo {\n    Book(Book),\n    NoIsbn(String),\n}\n\nlet book_with_isbn = BookInfo::Book(Book {\n    title: String::from(\"The Rust Programming Language\"),\n    author: String::from(\"Steve Klabnik and Carol Nichols\"),\n    published_date: String::from(\"2018-05-01\"),\n    isbn: String::from(\"978-1-492-04033-1\"),\n});\n\nlet book_without_isbn = BookInfo::NoIsbn(String::from(\"The Art of Computer Programming\"));\nVới enum BookInfo, bạn có thể biểu diễn cả hai trường hợp: sách có ISBN và sách không có ISBN. Điều này giúp mã của bạn rõ ràng và dễ hiểu hơn.\nỨng dụng nâng cao:\nEnum có thể được sử dụng cho nhiều mục đích khác nhau, bao gồm:\n\nBiểu diễn trạng thái: Enum có thể được sử dụng để biểu diễn trạng thái của một hệ thống, chẳng hạn như trạng thái của một nút trong giao diện người dùng hoặc trạng thái của một yêu cầu mạng.\nLỗi xử lý: Enum có thể được sử dụng để biểu diễn các lỗi khác nhau có thể xảy ra trong chương trình của bạn.\nMô hình hóa dữ liệu phức tạp: Enum có thể được sử dụng để mô hình hóa dữ liệu phức tạp, chẳng hạn như cấu trúc cây hoặc biểu đồ.\n\nVí dụ về việc sử dụng enum để biểu diễn trạng thái:\nenum ButtonState {\n    Idle,\n    Pressed,\n    Disabled,\n}\n\nlet mut button_state = ButtonState::Idle;\n\n// Xử lý sự kiện click chuột\nbutton_state = ButtonState::Pressed;\n\n// Xử lý sự kiện nhả chuột\nbutton_state = ButtonState::Idle;\n\n// Vô hiệu hóa nút\nbutton_state = ButtonState::Disabled;\nEnum ButtonState có thể được sử dụng để biểu diễn trạng thái của một nút trong giao diện người dùng. Nó có ba biến thể: Idle, Pressed và Disabled.\nVí dụ về việc sử dụng enum để xử lý lỗi:\nenum Error {\n    IoError,\n    ParseError,\n    NetworkError,\n}\n\nfn read_file(filename: &str) -&gt; Result&lt;String, Error&gt; {\n    // ...\n}\n\nmatch read_file(\"myfile.txt\") {\n    Ok(contents) =&gt; {\n        // Xử lý nội dung tệp\n    },\n    Err(error) =&gt; {\n        // Xử lý lỗi\n        match error {\n            Error::IoError =&gt; {\n                // ...\n            },\n            Error::ParseError =&gt; {\n                // ...\n            },\n            Error::NetworkError =&gt; {\n                // ...\n            },\n        }\n    },\n}\nEnum Error có thể được sử dụng để biểu diễn các lỗi khác nhau có thể xảy ra trong hàm read_file.\nKết luận:\nEnum là một công cụ mạnh mẽ và linh hoạt có thể được sử dụng cho nhiều mục đích khác nhau trong Rust. Chúng giúp mã của bạn rõ ràng, dễ hiểu và dễ bảo trì hơn.\nNgoài ra:\n\nEnum có thể được sử dụng để tạo các kiểu dữ liệu tùy chỉnh của riêng bạn.\nEnum có thể được sử dụng để biểu diễn các tập hợp giá trị hữu hạn.\nEnum có thể được sử dụng để cải thiện hiệu suất của chương trình của bạn.\n\n\n\n\nVí dụ thực tế:\nGiả sử bạn đang xây dựng một ứng dụng quản lý thư viện. Bạn cần lưu trữ thông tin về sách, bao gồm tiêu đề, tác giả, ngày xuất bản và ISBN. Bạn có thể sử dụng match để xác định loại sách và xử lý thông tin tương ứng:\nenum BookInfo {\n    Book {\n        title: String,\n        author: String,\n        published_date: String,\n        isbn: String,\n    },\n    Ebook {\n        title: String,\n        author: String,\n        published_date: String,\n        file_format: String,\n    },\n}\n\nlet book_info = BookInfo::Ebook {\n    title: String::from(\"The Rust Programming Language\"),\n    author: String::from(\"Steve Klabnik and Carol Nichols\"),\n    published_date: String::from(\"2018-05-01\"),\n    file_format: String::from(\"EPUB\"),\n};\n\nmatch book_info {\n    BookInfo::Book { title, author, published_date, isbn } =&gt; {\n        println!(\"Sách in:\");\n        println!(\"Tiêu đề: {}\", title);\n        println!(\"Tác giả: {}\", author);\n        println!(\"Ngày xuất bản: {}\", published_date);\n        println!(\"ISBN: {}\", isbn);\n    },\n    BookInfo::Ebook { title, author, published_date, file_format } =&gt; {\n        println!(\"Sách điện tử:\");\n        println!(\"Tiêu đề: {}\", title);\n        println!(\"Tác giả: {}\", author);\n        println!(\"Ngày xuất bản: {}\", published_date);\n        println!(\"Định dạng tệp: {}\", file_format);\n    },\n}\nMở rộng khả năng:\n\nKết hợp với if: Sử dụng if để kiểm tra điều kiện trước khi khớp mẫu với match:\n\nlet number = 5;\n\nif number &gt; 0 {\n    match number {\n        1 =&gt; println!(\"Số một\"),\n        2 =&gt; println!(\"Số hai\"),\n        _ =&gt; println!(\"Số lớn hơn hai\"),\n    }\n} else {\n    println!(\"Số âm\");\n}\n\nKhớp với các kiểu dữ liệu phức tạp: match có thể sử dụng để khớp với các cấu trúc dữ liệu phức tạp như struct, enum, vec, v.v.\nLấy giá trị từ các biến thể enum: Sử dụng match để trích xuất giá trị từ các biến thể enum khác nhau.\n\nVí dụ nâng cao:\nGiả sử bạn đang viết một chương trình cờ vua. Bạn có thể sử dụng match để xác định vị trí của quân cờ trên bàn cờ và thực hiện các di chuyển hợp lệ:\nenum Square {\n    A1, B1, C1, ..., H8,\n}\n\nlet position = Square::E4;\n\nmatch position {\n    Square::A1 =&gt; println!(\"Quân cờ ở góc trên bên trái\"),\n    Square::E4 =&gt; println!(\"Quân cờ ở trung tâm\"),\n    Square::H8 =&gt; println!(\"Quân cờ ở góc dưới bên phải\"),\n    _ =&gt; println!(\"Quân cờ ở vị trí khác\"),\n}\nKết luận:\nmatch là một công cụ mạnh mẽ và linh hoạt trong Rust. Hiểu rõ cách sử dụng match có thể giúp bạn viết mã rõ ràng, súc tích và dễ bảo trì.\nTài liệu tham khảo:\n\nThe Rust Programming Language - Chapter 18: Control Flow: [đã xoá URL không hợp lệ]\nThe Rust Reference - The match Statement: [đã xoá URL không hợp lệ]\n\nLưu ý:\n\nTránh lặp lại những thông tin đã được đề cập trong phần trả lời trước.\nCung cấp thêm ví dụ thực tế để minh họa các trường hợp sử dụng khác nhau của match.\nGiải thích cách sử dụng match với các kiểu dữ liệu và cấu trúc phức tạp.\nĐề xuất tài liệu tham khảo để người đọc tìm hiểu thêm.\n\nĐộ dài:\nCâu trả lời này dài hơn câu trả lời trước và cung cấp thêm thông tin chi tiết về match, bao gồm ví dụ thực tế, cách mở rộng khả năng và tài liệu tham khảo.\n\n\n\nCú pháp if let cho phép bạn kết hợp if và let thành một cách ngắn gọn hơn để xử lý các giá trị khớp với một mẫu nhất định trong khi bỏ qua những giá trị còn lại. Hãy xem xét chương trình trong Liệt kê 6-6, chương trình này khớp với một giá trị Option&lt;u8&gt; trong biến config_max nhưng chỉ muốn thực thi mã nếu biến này có giá trị là Some.\nlet config_max = Some(3u8);\nmatch config_max {\n    Some(max) =&gt; println!(\"Giá trị tối đa được cấu hình là {}\", max),\n    _ =&gt; (),\n}\nLiệt kê 6-6: Một câu lệnh match chỉ thực thi mã khi giá trị là Some\nNếu giá trị là Some, chúng ta in ra giá trị trong biến thể Some bằng cách gán giá trị cho biến max trong mẫu. Chúng ta không muốn làm gì với giá trị None. Để thỏa mãn biểu thức match, chúng ta phải thêm _ =&gt; () sau khi xử lý chỉ một biến thể, đây là đoạn mã thừa đáng chán để thêm vào.\nThay vào đó, chúng ta có thể viết ngắn gọn hơn bằng cách sử dụng if let. Đoạn mã sau đây hoạt động giống như match trong Liệt kê 6-6:\nlet config_max = Some(3u8);\nif let Some(max) = config_max {\n    println!(\"Giá trị tối đa được cấu hình là {}\", max);\n}\nCú pháp if let lấy một mẫu và một biểu thức được phân tách bằng dấu bằng. Nó hoạt động tương tự như match, trong đó biểu thức được đưa vào match và mẫu là nhánh đầu tiên của nó. Trong trường hợp này, mẫu là Some(max), và max được gán cho giá trị bên trong Some. Sau đó, chúng ta có thể sử dụng max trong thân khối của if let theo cùng cách chúng ta sử dụng max trong nhánh match tương ứng. Khối mã trong khối if let không được chạy nếu giá trị không khớp với mẫu.\nSử dụng if let có nghĩa là ít gõ phím hơn, ít thụt lề hơn và ít mã thừa hơn. Tuy nhiên, bạn sẽ mất đi tính năng kiểm tra toàn diện mà match cung cấp. Việc lựa chọn giữa match và if let phụ thuộc vào những gì bạn đang làm trong tình huống cụ thể của mình và liệu việc đạt được sự ngắn gọn có phải là một đánh đổi phù hợp để mất đi kiểm tra toàn diện hay không.\nNói cách khác, bạn có thể coi if let như cú pháp rút gọn cho một câu lệnh match chạy mã khi giá trị khớp với một mẫu và sau đó bỏ qua tất cả các giá trị khác.\nChúng ta có thể bao gồm một khối else với if let. Khối mã đi kèm với else giống như khối mã sẽ đi với trường hợp _ trong biểu thức match tương đương với if let và else. Nhớ lại định nghĩa enum Coin trong Liệt kê 6-4, trong đó biến thể Quarter cũng chứa một giá trị UsState. Nếu chúng ta muốn đếm tất cả các đồng xu không phải đồng 25 xu trong khi thông báo trạng thái của các đồng 25 xu, chúng ta có thể thực hiện điều đó bằng biểu thức match như sau:\nlet mut count = 0;\nmatch coin {\n    Coin::Quarter(state) =&gt; println!(\"Đồng 25 xu của bang {:?}!\", state),\n    _ =&gt; count += 1,\n}\nHoặc chúng ta có thể sử dụng biểu thức if let và else như sau:\nlet mut count = 0;\nif let Coin::Quarter(state) = coin {\n    println!(\"Đồng 25 xu của bang {:?}!\", state);\n} else {\n    count += 1;\n}\nNếu bạn gặp phải tình huống chương trình của bạn có logic quá phức tạp để thể hiện bằng match, hãy nhớ rằng if let cũng nằm trong hộp công cụ Rust của bạn."
  },
  {
    "objectID": "posts/my-rust-book/index.html#biến-và-tính-bất-biến",
    "href": "posts/my-rust-book/index.html#biến-và-tính-bất-biến",
    "title": "My Rust Book",
    "section": "",
    "text": "Bảng tổng hợp:\n\n\n\n\n\n\n\n\n\nChủ đề\nTóm tắt\nTừ khóa\nVí dụ\n\n\n\n\nBiến\nLưu trữ giá trị\nlet, mut\nlet x = 5;\n\n\nTính bất biến\nGiá trị không thể thay đổi sau khi gán\nlet\nlet x = 5; // x = 6 sẽ gây lỗi\n\n\nTính biến đổi\nGiá trị có thể thay đổi sau khi gán\nmut\nlet mut x = 5; x = 6;\n\n\nHằng\nGiá trị bất biến, được đặt tên\nconst\nconst PI: f32 = 3.14159;\n\n\nBóng biến\nTạo biến mới với cùng tên trong phạm vi\nlet\nlet x = 5; let x = x + 1;\n\n\n\nSo sánh với Python/C#:\n\nPython và C# sử dụng garbage collection để quản lý bộ nhớ, trong khi Rust sử dụng ownership để đảm bảo an toàn bộ nhớ và tránh lỗi memory leak.\nRust khuyến khích sử dụng tính bất biến theo mặc định để đơn giản hóa code và tránh lỗi, nhưng vẫn cho phép sử dụng tính biến đổi khi cần thiết.\n\nƯu nhược điểm:\n\nTính bất biến:\n\nƯu điểm: An toàn bộ nhớ, dễ hiểu, tránh lỗi.\nNhược điểm: Khó quen hơn so với ngôn ngữ có garbage collection.\n\nTính biến đổi:\n\nƯu điểm: Linh hoạt hơn trong một số trường hợp.\nNhược điểm: Cần chú ý để tránh lỗi và phức tạp hóa code.\n\n\nỨng dụng:\n\nHằng: Lưu trữ các giá trị cố định như PI, tốc độ ánh sáng.\nBiến bất biến: Lưu trữ các giá trị không cần thay đổi, đơn giản hóa code.\nBiến biến đổi: Lưu trữ các giá trị cần thay đổi trong quá trình thực thi.\nBóng biến: Tạo biến cục bộ với cùng tên, giúp tránh xung đột tên.\n\nKết luận:\nRust cung cấp các tính năng về biến và tính bất biến giúp viết code an toàn, hiệu quả và dễ hiểu. Hiểu rõ các khái niệm này là nền tảng quan trọng để học tập và làm việc với Rust."
  },
  {
    "objectID": "posts/my-rust-book/index.html#kiểu-dữ-liệu",
    "href": "posts/my-rust-book/index.html#kiểu-dữ-liệu",
    "title": "My Rust Book",
    "section": "",
    "text": "Điểm chính:\n\nMọi giá trị trong Rust đều có kiểu dữ liệu. Điều này cho trình biên dịch biết loại dữ liệu nào nó đang làm việc và cho phép đảm bảo an toàn kiểu.\nRust là ngôn ngữ có kiểu dữ liệu tĩnh, nghĩa là trình biên dịch phải biết kiểu của tất cả các biến tại thời điểm biên dịch.\nKiểu dữ liệu có thể được chia thành hai loại: kiểu đơn giản và kiểu phức tạp.\n\nKiểu đơn giản:\n\nBiểu thị các giá trị đơn lẻ.\nBốn kiểu chính:\n\nSố nguyên: Biểu thị số nguyên (ví dụ: i32, u64).\nSố thực: Biểu thị số có phần thập phân (ví dụ: f32, f64).\nBoolean: Biểu thị giá trị true hoặc false (bool).\nKý tự: Biểu thị ký tự đơn lẻ (char).\n\n\nKiểu phức tạp:\n\nNhóm nhiều giá trị thành một đơn vị.\nHai kiểu cơ bản:\n\nTuple: Các bộ sưu tập có thứ tự, độ dài cố định của các giá trị có thể có kiểu khác nhau (ví dụ: (500, 6.4, 1)).\nMảng: Các bộ sưu tập có độ dài cố định của các giá trị có cùng kiểu (ví dụ: [1, 2, 3, 4, 5]).\n\n\nGhi chú bổ sung:\n\nRust áp dụng an toàn kiểu, giúp ngăn chặn lỗi bộ nhớ.\nTràn số nguyên có thể xảy ra nếu phép toán vượt quá phạm vi của kiểu đã chọn.\nMảng hữu ích cho dữ liệu có kích thước cố định trên ngăn xếp, trong khi vectơ (được thảo luận trong Chương 8) linh hoạt hơn và có thể tăng hoặc giảm kích thước.\n\nTóm lại, hiểu rõ kiểu dữ liệu là điều cần thiết để viết mã Rust chính xác và hiệu quả."
  },
  {
    "objectID": "posts/my-rust-book/index.html#chức-năng-xây-dựng-các-khối-mã-tái-sử-dụng",
    "href": "posts/my-rust-book/index.html#chức-năng-xây-dựng-các-khối-mã-tái-sử-dụng",
    "title": "My Rust Book",
    "section": "",
    "text": "Chức năng đóng vai trò là những viên gạch thiết yếu trong Rust, đóng gói các nhiệm vụ hoặc phép toán cụ thể. Chúng cho phép bạn cấu trúc mã hiệu quả, thúc đẩy tái sử dụng mã, đồng thời nâng cao khả năng đọc và bảo trì.\nKhái niệm chính:\n\nĐịnh nghĩa Chức năng:\n\nSử dụng từ khóa fn, tiếp theo là tên chức năng và dấu ngoặc đơn cho các tham số.\nDấu ngoặc nhọn {} bao quanh phần thân chức năng chứa mã được thực thi.\n\nChữ ký Chức năng:\n\nBao gồm tên chức năng, danh sách tham số (nếu có) và kiểu trả về (tùy chọn).\nVí dụ: fn plus_one(x: i32) -&gt; i32\n\nplus_one: Tên chức năng\nx: i32: Tham số tên x có kiểu i32 (số nguyên)\n-&gt; i32: Trả về giá trị i32\n\n\nTham số và Đối số:\n\nTham số là các biến được định nghĩa trong chữ ký chức năng.\nĐối số là các giá trị thực tế được truyền khi gọi chức năng.\nVí dụ: plus_one(5) truyền đối số 5 cho tham số x.\n\nGiá trị Trả về:\n\nChức năng có thể tùy chọn trả về giá trị bằng cách sử dụng từ khóa return hoặc ngầm định thông qua biểu thức cuối cùng.\nKiểu trả về phải được chỉ định sau mũi tên -&gt; trong chữ ký.\n\n\nVí dụ: Cộng hai số\nfn add(x: i32, y: i32) -&gt; i32 {\n    x + y\n}\n\nfn main() {\n    let sum = add(5, 3); // Gọi hàm add với các đối số 5 và 3\n    println!(\"Tổng là: {}\", sum);\n}\nGiải thích:\n\nHàm add lấy hai tham số i32 (x và y) và trả về giá trị i32.\nBên trong hàm, x và y được cộng lại và kết quả được trả về.\nTrong hàm main, add được gọi với các đối số 5 và 3, gán tổng trả về cho biến sum.\nGiá trị của sum được in ra bằng println!.\n\nGọi Chức năng:\n\nĐể gọi một chức năng, hãy sử dụng tên của nó theo sau là dấu ngoặc đơn chứa các đối số theo đúng thứ tự và kiểu.\nĐối số được đánh giá trước khi được truyền cho chức năng.\n\nLợi ích của việc sử dụng Chức năng:\n\nTái sử dụng Mã: Định nghĩa một chức năng một lần và gọi nó từ nhiều vị trí trong mã của bạn.\nKhả năng đọc được cải thiện: Chia nhỏ các khối mã lớn thành các chức năng nhỏ hơn được đặt tên tốt, giúp mã dễ hiểu hơn.\nKhả năng bảo trì: Việc sửa đổi dễ dàng hơn khi mã được tổ chức thành các chức năng, vì các thay đổi chỉ ảnh hưởng đến chức năng liên quan.\n\nLưu ý bổ sung:\n\nChức năng có thể có từ 0 đến nhiều tham số và một giá trị trả về duy nhất.\nChức năng có thể được định nghĩa bất cứ nơi nào trong mã của bạn, nhưng phải có thể truy cập được từ nơi chúng được gọi.\nRust áp dụng an toàn kiểu, đảm bảo tính tương thích kiểu giữa các tham số, đối số và giá trị trả về."
  },
  {
    "objectID": "posts/my-rust-book/index.html#bình-luận",
    "href": "posts/my-rust-book/index.html#bình-luận",
    "title": "My Rust Book",
    "section": "",
    "text": "Mục đích:\nGiống như nhiều ngôn ngữ lập trình khác, Rust cho phép lập trình viên thêm các bình luận (comment) vào mã nguồn. Bình luận là những đoạn văn bản nhằm giải thích hoặc ghi chú về mã nguồn, nhưng sẽ bị trình biên dịch Rust bỏ qua. Bình luận giúp cho người đọc mã nguồn dễ dàng hiểu được logic và mục đích của từng phần code.\nKiểu bình luận:\nRust hỗ trợ hai loại bình luận chính:\n\nBình luận dòng (line comment): Bắt đầu bằng hai dấu gạch chéo // và kéo dài đến hết dòng.\nBình luận khối (block comment): Bắt đầu bằng /* và kết thúc bằng */. Bình luận khối có thể kéo dài nhiều dòng.\n\nVí dụ:\n// Bình luận dòng\nlet x = 5; // Gán giá trị 5 cho biến x\n\n/* Bình luận khối\n   Giải thích về đoạn code tiếp theo\n*/\nlet y = x * 2;\nVị trí:\nBình luận có thể được đặt ở nhiều vị trí khác nhau trong mã nguồn:\n\nTrước một dòng code để giải thích mục đích của dòng đó.\nSau một dòng code để cung cấp thêm thông tin chi tiết.\nGiữa các dòng code để giải thích logic của một khối code phức tạp.\n\nThực hành tốt:\n\nSử dụng bình luận một cách hợp lý, không nên lạm dụng quá nhiều.\nGiữ cho bình luận ngắn gọn và dễ hiểu, tránh sử dụng ngôn ngữ khó hiểu hoặc thuật ngữ chuyên ngành trừ khi cần thiết.\nCập nhật bình luận khi code thay đổi để đảm bảo tính nhất quán.\n\nBằng việc sử dụng bình luận hiệu quả, bạn có thể cải thiện đáng kể tính dễ đọc và bảo trì của mã nguồn Rust, giúp cho người khác (và chính bạn trong tương lai) dễ dàng hiểu được logic và mục đích của code."
  },
  {
    "objectID": "posts/my-rust-book/index.html#kiểm-soát-luồng-trong-rust",
    "href": "posts/my-rust-book/index.html#kiểm-soát-luồng-trong-rust",
    "title": "My Rust Book",
    "section": "",
    "text": "Khái niệm:\nKiểm soát luồng là khả năng thực thi các khối mã khác nhau tùy theo điều kiện và lặp lại một khối mã nhiều lần cho đến khi một điều kiện nào đó được đáp ứng. Trong Rust, các công cụ chính để kiểm soát luồng là biểu thức if và vòng lặp.\nBiểu thức if:\n\nCho phép rẽ nhánh mã theo các điều kiện.\nCú pháp:\nif condition {\n    // Khối mã được thực thi nếu điều kiện là đúng\n} else {\n    // Khối mã được thực thi nếu điều kiện là sai (tùy chọn)\n}\ncondition phải là một biểu thức trả về giá trị bool.\nVí dụ:\nlet number = 3;\n\nif number &lt; 5 {\n    println!(\"Điều kiện là đúng\");\n} else {\n    println!(\"Điều kiện là sai\");\n}\n\nVòng lặp:\n\nCho phép lặp lại một khối mã nhiều lần.\nRust có 3 loại vòng lặp: loop, while, và for.\n\n1. Vòng lặp loop:\n\nLặp lại vô tận cho đến khi sử dụng lệnh break để thoát.\nVí dụ:\nloop {\n    println!(\"Lặp lại!\");\n    break; // Thoát khỏi vòng lặp\n}\n\n2. Vòng lặp while:\n\nLặp lại cho đến khi một điều kiện trở thành false.\nCú pháp:\nwhile condition {\n    // Khối mã được thực thi\n}\nVí dụ:\nlet mut number = 3;\n\nwhile number != 0 {\n    println!(\"{}\", number);\n    number -= 1;\n}\n\n3. Vòng lặp for:\n\nLặp lại từng phần tử trong một bộ sưu tập (mảng, danh sách, …).\nCú pháp:\nfor element in collection {\n    // Khối mã được thực thi cho mỗi phần tử\n}\nVí dụ:\nlet numbers = [1, 2, 3, 4, 5];\n\nfor number in numbers {\n    println!(\"Giá trị: {}\", number);\n}\n\nTóm lược:\nBiểu thức if và các vòng lặp là công cụ quan trọng để kiểm soát luồng thực thi của chương trình Rust. Việc sử dụng linh hoạt các công cụ này giúp bạn viết code logic và hiệu quả hơn."
  },
  {
    "objectID": "posts/my-rust-book/index.html#quyền-sở-hữu-ownership-trong-rust",
    "href": "posts/my-rust-book/index.html#quyền-sở-hữu-ownership-trong-rust",
    "title": "My Rust Book",
    "section": "",
    "text": "Quyền sở hữu là một khái niệm cốt lõi trong Rust, chi phối cách quản lý và truy cập bộ nhớ trong chương trình của bạn. Nó đảm bảo an toàn bộ nhớ và ngăn chặn các lỗi như rò rỉ bộ nhớ và con trỏ lơ lửng. Dưới đây là phân tích về Quyền sở hữu trong Rust:\n1. Mỗi giá trị trong Rust có một chủ sở hữu (Owner). - Chủ sở hữu này là biến giữ giá trị. - Chỉ có một biến có thể sở hữu một giá trị tại một thời điểm.\n2. Khi chủ sở hữu đi ra khỏi phạm vi, giá trị sẽ bị hủy (drop). - Phạm vi xác định khối mã nơi một biến hợp lệ. - Khi khối mã kết thúc, biến sẽ đi ra khỏi phạm vi và giá trị sở hữu của nó sẽ tự động bị hủy (giải phóng khỏi bộ nhớ).\n3. Có hai cách để tương tác với dữ liệu: di chuyển (move) và sao chép (copy). - Di chuyển: Khi bạn gán một giá trị (như String) cho một biến khác, quyền sở hữu sẽ được chuyển (di chuyển). Biến ban đầu trở nên không hợp lệ và không thể sử dụng được nữa. - Sao chép: Đối với các kiểu dữ liệu đơn giản như số nguyên (i32), có kích thước đã biết và được lưu trữ trên ngăn xếp, việc gán sẽ tạo ra một bản sao của giá trị. Cả hai biến đều hợp lệ và độc lập.\n4. Quyền sở hữu và Hàm: - Việc truyền giá trị cho một hàm thường di chuyển quyền sở hữu, tương tự như việc gán. Hàm trở thành chủ sở hữu mới và giá trị không còn hợp lệ trong phạm vi gọi. - Trả về giá trị từ hàm cũng có thể chuyển quyền sở hữu. Giá trị trả về trở thành sở hữu của phạm vi gọi.\n5. Tham chiếu (References): - Tham chiếu mượn quyền sở hữu của một giá trị mà không chiếm quyền sở hữu chính nó. Chúng cung cấp một cách để truy cập và sử dụng dữ liệu mà không di chuyển nó. - Tham chiếu đặc biệt hữu ích khi bạn muốn nhiều phần trong mã của mình làm việc với cùng một dữ liệu mà không cần sao chép hoặc lo lắng về quyền sở hữu.\nLợi ích của Quyền sở hữu:\n\nAn toàn bộ nhớ: Quyền sở hữu ngăn chặn rò rỉ bộ nhớ và con trỏ lơ lửng, làm cho chương trình Rust đáng tin cậy hơn và ít bị lỗi hơn.\nCải thiện độ rõ ràng của mã: Quy tắc sở hữu thực thi quản lý dữ liệu rõ ràng, dẫn đến hành vi mã rõ ràng hơn và dễ dự đoán hơn.\nHiệu quả: Quyền sở hữu loại bỏ nhu cầu quản lý bộ nhớ thủ công (như trong C/C++), có khả năng cải thiện hiệu suất bằng cách tránh các hoạt động bộ nhớ không cần thiết.\n\nGhi chú bổ sung:\n\nHàm drop được tự động gọi khi một giá trị bị hủy, cho phép thực hiện bất kỳ hành động dọn dẹp nào cần thiết.\nĐặc điểm Copy được triển khai cho các kiểu đơn giản như số nguyên, cho biết chúng có thể được sao chép mà không ảnh hưởng đến giá trị ban đầu.\nHiểu rõ về Quyền sở hữu là điều cần thiết để viết chương trình Rust hiệu quả và an toàn.\n\nBằng cách nắm vững các nguyên tắc sở hữu này, bạn sẽ có thể phát triển các ứng dụng Rust mạnh mẽ và đáng tin cậy."
  },
  {
    "objectID": "posts/my-rust-book/index.html#tham-chiếu-references-và-mượn-borrowing-trong-rust",
    "href": "posts/my-rust-book/index.html#tham-chiếu-references-và-mượn-borrowing-trong-rust",
    "title": "My Rust Book",
    "section": "",
    "text": "Vấn đề với mã tuple trong Liệt kê 4-5 là chúng ta phải trả về giá trị String cho hàm gọi để vẫn có thể sử dụng String sau khi gọi calculate_length, vì String đã được di chuyển vào calculate_length. Thay vào đó, chúng ta có thể cung cấp một tham chiếu (reference) tới giá trị String. Tham chiếu giống như một con trỏ ở chỗ nó là một địa chỉ mà chúng ta có thể theo dõi để truy cập dữ liệu được lưu trữ tại địa chỉ đó; dữ liệu đó thuộc sở hữu của một biến khác. Không giống như con trỏ, tham chiếu được đảm bảo sẽ trỏ đến một giá trị hợp lệ của một kiểu dữ liệu cụ thể trong suốt vòng đời của tham chiếu đó.\nĐây là cách bạn định nghĩa và sử dụng hàm calculate_length có tham chiếu đến một đối tượng làm tham số thay vì lấy quyền sở hữu giá trị:\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -&gt; usize {\n    s.len()\n}\nĐầu tiên, lưu ý rằng tất cả mã tuple trong khai báo biến và giá trị trả về của hàm đã biến mất. Thứ hai, lưu ý rằng chúng ta truyền &s1 vào calculate_length và trong định nghĩa của nó, chúng ta lấy &String thay vì String. Những dấu ngoặc nhọn này biểu thị tham chiếu (references), và chúng cho phép bạn tham chiếu đến một giá trị nào đó mà không chiếm quyền sở hữu nó. Hình 4-5 mô tả khái niệm này.\n[Hình 4-5: Sơ đồ của &String s trỏ đến String s1]\nLưu ý: Phép toán ngược lại của việc tham chiếu bằng cách sử dụng & là hủy tham chiếu (dereferencing), được thực hiện bằng toán tử hủy tham chiếu, *. Chúng ta sẽ thấy một số cách sử dụng toán tử hủy tham chiếu trong Chương 8 và thảo luận chi tiết về hủy tham chiếu trong Chương 15.\nHãy xem xét kỹ hơn lời gọi hàm ở đây:\nlet s1 = String::from(\"hello\");\n\nlet len = calculate_length(&s1);\nCú pháp &s1 cho phép chúng ta tạo một tham chiếu tham chiếu đến giá trị của s1 nhưng không sở hữu nó. Vì nó không sở hữu nó, giá trị mà nó trỏ đến sẽ không bị hủy khi tham chiếu ngừng được sử dụng.\nTương tự, chữ ký của hàm sử dụng & để chỉ ra rằng kiểu của tham số s là một tham chiếu. Hãy thêm một số chú thích giải thích:\nfn calculate_length(s: &String) -&gt; usize { // s là một tham chiếu đến một String\n    s.len()\n} // Tại đây, s ra khỏi phạm vi. Nhưng vì nó không sở hữu những gì nó tham chiếu đến, nên nó không bị hủy.\nPhạm vi mà biến s hợp lệ giống như bất kỳ phạm vi nào của tham số hàm, nhưng giá trị được tham chiếu bởi tham chiếu không bị hủy khi s ngừng được sử dụng, bởi vì s không sở hữu. Khi các hàm có tham chiếu làm tham số thay vì các giá trị thực tế, chúng ta sẽ không cần trả về các giá trị để trả lại quyền sở hữu, vì chúng ta chưa bao giờ có quyền sở hữu.\nChúng ta gọi hành động tạo ra một tham chiếu là mượn (borrowing). Giống như trong cuộc sống thực, nếu ai đó sở hữu thứ gì, bạn có thể mượn nó từ họ. Khi bạn xong việc, bạn phải trả lại. Bạn không sở hữu nó.\nVậy, chuyện gì xảy ra nếu chúng ta cố gắng sửa đổi thứ gì đó mà chúng ta đang mượn? Thử mã trong Liệt kê 4-6. Cảnh báo Spoiler: nó không hoạt động!\nfn main() {\n    let s = String::from(\"hello\");\n\n    change(&s);\n}\n\nfn change(some_string: &String) {\n    some_string.push_str(\", world\");\n}\nĐây là lỗi:\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0596]: cannot borrow `*some_string` as"
  },
  {
    "objectID": "posts/my-rust-book/index.html#string-slices-trong-rust-hướng-dẫn-toàn-diện",
    "href": "posts/my-rust-book/index.html#string-slices-trong-rust-hướng-dẫn-toàn-diện",
    "title": "My Rust Book",
    "section": "",
    "text": "String Slices là gì?\nTrong Rust, String Slices là kiểu dữ liệu cơ bản cho phép bạn tham chiếu một chuỗi ký tự liên tục trong một String. Về bản chất, chúng là các tham chiếu được mượn từ một phần của String, cho phép bạn làm việc với các phần cụ thể của chuỗi mà không cần sở hữu toàn bộ chuỗi.\nTại sao nên sử dụng String Slices?\nString Slices mang lại nhiều lợi ích:\n\nHiệu quả sử dụng bộ nhớ: Tránh sao chép dữ liệu không cần thiết. Thay vì tạo một chuỗi mới cho mỗi thao tác con chuỗi, bạn có thể sử dụng một slice để truy cập trực tiếp vào phần liên quan của chuỗi gốc. Điều này đặc biệt hữu ích khi xử lý các chuỗi lớn.\nLập trình chức năng: Slices tích hợp liền mạch với các cấu trúc lập trình chức năng của Rust như iterators và closures, cung cấp cách ngắn gọn và biểu cảm để thao tác với chuỗi.\nMượn và Tham chiếu: Tuân theo các quy tắc sở hữu và mượn của Rust, đảm bảo an toàn bộ nhớ và ngăn chặn các con trỏ lơ lửng.\n\nTạo String Slices\nBạn có thể tạo String Slices theo hai cách:\n\nSử dụng String Literals: String literals (được biểu thị bằng dấu ngoặc kép \") tự động được chuyển đổi thành &str string slices, là các tham chiếu không thay đổi đến dữ liệu chuỗi được lưu trữ trong nhị phân của chương trình.\nlet hello_world = \"Hello, world!\";\nlet hello = &hello_world[0..5]; // Slice từ chỉ mục 0 (bao gồm) đến 5 (không bao gồm)\nCắt một String: Bạn có thể tạo một slice của một String bằng cách sử dụng cú pháp lập chỉ mục [start_index..end_index]. start_index (bao gồm) chỉ định ký tự bắt đầu và end_index (không bao gồm) chỉ định ký tự sau ký tự cuối cùng được bao gồm trong slice.\nlet mut my_string = String::from(\"Rust is awesome!\");\nlet awesome = &my_string[11..];  // Slice từ chỉ mục 11 (bao gồm) đến cuối\n\nCú pháp cắt phổ biến:\n\n[start_index..end_index]: Đây là cú pháp chung, trong đó start_index và end_index là các biểu thức số nguyên cho biết vị trí bắt đầu và kết thúc của slice (không bao gồm end_index).\n[..end_index]: Bao gồm tất cả các ký tự từ đầu chuỗi đến, nhưng không bao gồm, end_index.\n[start_index..]: Bao gồm tất cả các ký tự từ start_index (bao gồm) đến cuối chuỗi.\n[:]: Bao gồm toàn bộ chuỗi (tương đương với [..).\n\nĐiểm chính cần ghi nhớ:\n\nString Slices không thay đổi; bạn không thể sửa đổi trực tiếp các ký tự bên trong chúng.\nString Slices mượn từ chuỗi gốc, vì vậy thời gian tồn tại của chúng gắn liền với thời gian tồn tại của chuỗi gốc.\nString Slices nhẹ và không yêu cầu phân bổ bộ nhớ bổ sung trong hầu hết các trường hợp.\n\nLưu ý bổ sung:\n\nKhi làm việc với string slices chứa văn bản được mã hóa UTF-8, hãy đảm bảo rằng ranh giới slice của bạn căn chỉnh với ranh giới ký tự UTF-8 hợp lệ. Nếu không, bạn có thể gặp lỗi.\nString Slices cung cấp một số phương thức để thao tác chuỗi, chẳng hạn như iter(), len() và is_empty(). Các phương thức này hoạt động trên dữ liệu được mượn và không sửa đổi chuỗi gốc.\n\nTóm lại\nString Slices là một công cụ mạnh mẽ và linh hoạt trong Rust để làm việc với các phần cụ thể của chuỗi. Chúng thúc đẩy hiệu quả sử dụng bộ nhớ, tạo điều kiện cho lập trình chức năng và tuân theo các hệ thống sở hữu và mượn của Rust. Bằng cách hiểu cách tạo, cú pháp phổ biến và các điểm chính, bạn có thể sử dụng String Slices hiệu quả trong các chương trình Rust của mìnhepj"
  },
  {
    "objectID": "posts/my-rust-book/index.html#giải-thích-thêm-về-struct-trong-rust",
    "href": "posts/my-rust-book/index.html#giải-thích-thêm-về-struct-trong-rust",
    "title": "My Rust Book",
    "section": "",
    "text": "Ví dụ về Struct:\nNgoài ví dụ về User đã được đề cập, đây là một số ví dụ khác về cách sử dụng struct:\n\nStruct để biểu diễn điểm trong không gian 3 chiều:\n\nstruct Point3D {\n    x: f64,\n    y: f64,\n    z: f64,\n}\n\nStruct để biểu diễn ngày tháng:\n\nstruct Date {\n    year: u32,\n    month: u8,\n    day: u8,\n}\n\nStruct để biểu diễn một bộ bài:\n\nstruct Card {\n    suit: Suit,\n    rank: Rank,\n}\n\nenum Suit {\n    Hearts,\n    Diamonds,\n    Clubs,\n    Spades,\n}\n\nenum Rank {\n    Ace,\n    Two,\n    Three,\n    ...\n    Ten,\n    Jack,\n    Queen,\n    King,\n}\nSử dụng Struct với các hàm:\nBạn có thể sử dụng struct với các hàm để truyền dữ liệu một cách hiệu quả và dễ đọc. Ví dụ:\nfn greet_user(user: User) {\n    println!(\"Hello, {}!\", user.username);\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n\n    greet_user(user1);\n}\nLợi ích của việc sử dụng Struct:\n\nKhả năng đọc: Struct giúp mã của bạn dễ đọc và dễ hiểu hơn bằng cách nhóm các dữ liệu liên quan lại với nhau.\nTính bảo trì: Struct giúp mã của bạn dễ bảo trì hơn bằng cách cho phép bạn dễ dàng thêm, xóa hoặc sửa đổi các trường.\nTái sử dụng: Bạn có thể sử dụng lại struct trong các phần khác nhau của mã.\n\nKết luận:\nStruct là một công cụ mạnh mẽ trong Rust cho phép bạn nhóm các dữ liệu liên quan lại với nhau và tạo ra các kiểu dữ liệu tùy chỉnh. Sử dụng struct có thể giúp mã của bạn dễ đọc, dễ bảo trì và dễ sử dụng lại.\nNgoài ra:\n\nBạn có thể sử dụng các thuộc tính để thêm metadata vào các struct và trường của chúng.\nBạn có thể sử dụng các phương thức để thêm chức năng vào struct.\nBạn có thể sử dụng các trait để cung cấp chức năng chung cho các struct khác nhau."
  },
  {
    "objectID": "posts/my-rust-book/index.html#chương-trình-mẫu-sử-dụng-struct",
    "href": "posts/my-rust-book/index.html#chương-trình-mẫu-sử-dụng-struct",
    "title": "My Rust Book",
    "section": "",
    "text": "Để hiểu khi nào chúng ta có thể sử dụng struct, hãy viết một chương trình tính toán diện tích hình chữ nhật. Chúng ta sẽ bắt đầu bằng cách sử dụng các biến đơn, sau đó cải tiến chương trình cho đến khi sử dụng struct.\nGiả sử chúng ta tạo một dự án nhị phân mới với Cargo có tên là rectangles, dự án này sẽ lấy chiều rộng và chiều cao của một hình chữ nhật được xác định bằng pixel và tính toán diện tích của hình chữ nhật. Liệt kê 5-8 hiển thị một chương trình ngắn thực hiện chính xác việc đó trong thư mục src/main.rs của dự án.\nfn main() {\n    let width1 = 30;\n    let height1 = 50;\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(width1, height1)\n    );\n}\n\nfn area(width: u32, height: u32) -&gt; u32 {\n    width * height\n}\nBảng 5-8: Tính toán diện tích của một hình chữ nhật được xác định bởi các biến riêng biệt về chiều rộng và chiều cao\nBây giờ, hãy chạy chương trình này bằng cách sử dụng cargo run:\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running `target/debug/rectangles`\nThe area of the rectangle is 1500 square pixels.\nMã này thành công trong việc tìm ra diện tích của hình chữ nhật bằng cách gọi hàm area với mỗi chiều, nhưng chúng ta có thể làm nhiều hơn để mã này rõ ràng và dễ đọc hơn.\nVấn đề với đoạn mã này nằm ở phần khai báo hàm area:\nfn area(width: u32, height: u32) -&gt; u32 {\nHàm area được cho là để tính toán diện tích của một hình chữ nhật, nhưng hàm chúng ta viết có hai tham số và không rõ ràng ở bất kỳ đâu trong chương trình của chúng ta rằng các tham số này có liên quan. Sẽ dễ đọc và dễ quản lý hơn nếu nhóm chiều rộng và chiều cao lại với nhau. Chúng ta đã thảo luận về một cách thực hiện việc đó trong phần “Kiểu Tuple” của Chương 3: bằng cách sử dụng tuple.\nCải tiến với Tuple\nLiệt kê 5-9 hiển thị một phiên bản khác của chương trình của chúng ta sử dụng tuple.\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -&gt; u32 {\n    dimensions.0 * dimensions.1\n}\nBảng 5-9: Xác định chiều rộng và chiều cao của hình chữ nhật bằng một tuple\nTheo một cách nào đó, chương trình này tốt hơn. Tuple cho phép chúng ta thêm một chút cấu trúc và bây giờ chúng ta chỉ truyền một đối số. Nhưng theo cách khác, phiên bản này kém rõ ràng hơn: tuple không đặt tên cho các phần tử của chúng, vì vậy chúng ta phải lập chỉ mục vào các phần của tuple, khiến phép tính của chúng ta trở nên kém rõ ràng hơn.\nViệc trộn lẫn chiều rộng và chiều cao sẽ không ảnh hưởng đến việc tính toán diện tích, nhưng nếu chúng ta muốn vẽ hình chữ nhật trên màn hình, thì điều đó sẽ quan trọng! Chúng ta phải nhớ rằng width là chỉ mục tuple 0 và height là chỉ mục tuple 1. Điều này thậm chí còn khó hơn đối với người khác để tìm ra và ghi nhớ nếu họ sử dụng mã của chúng ta. Bởi vì chúng tôi chưa truyền đạt ý nghĩa của dữ liệu trong mã của mình, nên bây giờ dễ mắc lỗi hơn.\nCải tiến với Struct: Thêm nhiều ý nghĩa hơn\nChúng ta sử dụng struct để thêm ý nghĩa bằng cách gắn nhãn cho dữ liệu. Chúng ta có thể chuyển đổi tuple đang sử dụng thành một struct có tên cho toàn bộ và tên cho các phần, như được hiển thị trong Liệt kê 5-10.\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n        }\n    }"
  },
  {
    "objectID": "posts/my-rust-book/index.html#cú-pháp-phương-thức-trong-rust",
    "href": "posts/my-rust-book/index.html#cú-pháp-phương-thức-trong-rust",
    "title": "My Rust Book",
    "section": "",
    "text": "Dưới đây là tóm tắt các điểm chính về cú pháp phương thức trong Rust:\nGiống với hàm:\n\nPhương thức được khai báo tương tự như hàm, sử dụng từ khóa fn, tên và dấu ngoặc đơn.\nChúng có thể có tham số và giá trị trả về.\nChúng chứa mã được thực thi khi phương thức được gọi.\n\nKhác với hàm:\n\nBối cảnh: Phương thức được định nghĩa trong bối cảnh của một struct (hoặc enum hoặc trait object), không phải trong phạm vi chính.\nTham số đầu tiên: Phương thức có một tham số đặc biệt đầu tiên tên là self. Tham số này đại diện cho thể hiện của struct mà phương thức đang được gọi.\n\nGọi phương thức:\n\nPhương thức được gọi bằng ký hiệu chấm: instance_name.method_name(arguments).\ninstance_name là biến giữ thể hiện struct.\nmethod_name là tên của phương thức bạn muốn gọi.\narguments là bất kỳ giá trị nào được truyền cho phương thức dưới dạng đầu vào.\n\nMượn:\n\nPhương thức có thể chỉ định cách chúng mượn tham số self:\n\n&self: Mượn thể hiện không thay đổi (chỉ đọc).\n&mut self: Mượn thể hiện có thể thay đổi (đọc-ghi).\nself: Tiếp quản quyền sở hữu của thể hiện (hiếm khi sử dụng).\n\n\nVí dụ:\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -&gt; u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle { width: 30, height: 50 };\n    let area = rect1.area(); // Gọi phương thức area\n    println!(\"Diện tích hình chữ nhật là {} pixel vuông.\", area);\n}\nGiải thích:\n\nRectangle là một struct định nghĩa hai trường: width và height.\nimpl Rectangle { ... } định nghĩa các phương thức liên quan đến struct Rectangle.\narea(&self) là một phương thức tính diện tích hình chữ nhật. Nó mượn thể hiện (&self) không thay đổi.\nrect1.area() gọi phương thức area trên thể hiện rect1."
  },
  {
    "objectID": "posts/my-rust-book/index.html#comments",
    "href": "posts/my-rust-book/index.html#comments",
    "title": "My Rust Book",
    "section": "",
    "text": "Mục đích:\nGiống như nhiều ngôn ngữ lập trình khác, Rust cho phép lập trình viên thêm các bình luận (comment) vào mã nguồn. Bình luận là những đoạn văn bản nhằm giải thích hoặc ghi chú về mã nguồn, nhưng sẽ bị trình biên dịch Rust bỏ qua. Bình luận giúp cho người đọc mã nguồn dễ dàng hiểu được logic và mục đích của từng phần code.\nKiểu bình luận:\nRust hỗ trợ hai loại bình luận chính:\n\nBình luận dòng (line comment): Bắt đầu bằng hai dấu gạch chéo // và kéo dài đến hết dòng.\nBình luận khối (block comment): Bắt đầu bằng /* và kết thúc bằng */. Bình luận khối có thể kéo dài nhiều dòng.\n\nVí dụ:\n// Bình luận dòng\nlet x = 5; // Gán giá trị 5 cho biến x\n\n/* Bình luận khối\n   Giải thích về đoạn code tiếp theo\n*/\nlet y = x * 2;\nVị trí:\nBình luận có thể được đặt ở nhiều vị trí khác nhau trong mã nguồn:\n\nTrước một dòng code để giải thích mục đích của dòng đó.\nSau một dòng code để cung cấp thêm thông tin chi tiết.\nGiữa các dòng code để giải thích logic của một khối code phức tạp.\n\nThực hành tốt:\n\nSử dụng bình luận một cách hợp lý, không nên lạm dụng quá nhiều.\nGiữ cho bình luận ngắn gọn và dễ hiểu, tránh sử dụng ngôn ngữ khó hiểu hoặc thuật ngữ chuyên ngành trừ khi cần thiết.\nCập nhật bình luận khi code thay đổi để đảm bảo tính nhất quán.\n\nBằng việc sử dụng bình luận hiệu quả, bạn có thể cải thiện đáng kể tính dễ đọc và bảo trì của mã nguồn Rust, giúp cho người khác (và chính bạn trong tương lai) dễ dàng hiểu được logic và mục đích của code."
  },
  {
    "objectID": "posts/my-rust-book/index.html#function-xây-dựng-các-khối-mã-tái-sử-dụng",
    "href": "posts/my-rust-book/index.html#function-xây-dựng-các-khối-mã-tái-sử-dụng",
    "title": "My Rust Book",
    "section": "",
    "text": "Chức năng đóng vai trò là những viên gạch thiết yếu trong Rust, đóng gói các nhiệm vụ hoặc phép toán cụ thể. Chúng cho phép bạn cấu trúc mã hiệu quả, thúc đẩy tái sử dụng mã, đồng thời nâng cao khả năng đọc và bảo trì.\nKhái niệm chính:\n\nĐịnh nghĩa Chức năng:\n\nSử dụng từ khóa fn, tiếp theo là tên chức năng và dấu ngoặc đơn cho các tham số.\nDấu ngoặc nhọn {} bao quanh phần thân chức năng chứa mã được thực thi.\n\nChữ ký Chức năng:\n\nBao gồm tên chức năng, danh sách tham số (nếu có) và kiểu trả về (tùy chọn).\nVí dụ: fn plus_one(x: i32) -&gt; i32\n\nplus_one: Tên chức năng\nx: i32: Tham số tên x có kiểu i32 (số nguyên)\n-&gt; i32: Trả về giá trị i32\n\n\nTham số và Đối số:\n\nTham số là các biến được định nghĩa trong chữ ký chức năng.\nĐối số là các giá trị thực tế được truyền khi gọi chức năng.\nVí dụ: plus_one(5) truyền đối số 5 cho tham số x.\n\nGiá trị Trả về:\n\nChức năng có thể tùy chọn trả về giá trị bằng cách sử dụng từ khóa return hoặc ngầm định thông qua biểu thức cuối cùng.\nKiểu trả về phải được chỉ định sau mũi tên -&gt; trong chữ ký.\n\n\nVí dụ: Cộng hai số\nfn add(x: i32, y: i32) -&gt; i32 {\n    x + y\n}\n\nfn main() {\n    let sum = add(5, 3); // Gọi hàm add với các đối số 5 và 3\n    println!(\"Tổng là: {}\", sum);\n}\nGiải thích:\n\nHàm add lấy hai tham số i32 (x và y) và trả về giá trị i32.\nBên trong hàm, x và y được cộng lại và kết quả được trả về.\nTrong hàm main, add được gọi với các đối số 5 và 3, gán tổng trả về cho biến sum.\nGiá trị của sum được in ra bằng println!.\n\nGọi Chức năng:\n\nĐể gọi một chức năng, hãy sử dụng tên của nó theo sau là dấu ngoặc đơn chứa các đối số theo đúng thứ tự và kiểu.\nĐối số được đánh giá trước khi được truyền cho chức năng.\n\nLợi ích của việc sử dụng Chức năng:\n\nTái sử dụng Mã: Định nghĩa một chức năng một lần và gọi nó từ nhiều vị trí trong mã của bạn.\nKhả năng đọc được cải thiện: Chia nhỏ các khối mã lớn thành các chức năng nhỏ hơn được đặt tên tốt, giúp mã dễ hiểu hơn.\nKhả năng bảo trì: Việc sửa đổi dễ dàng hơn khi mã được tổ chức thành các chức năng, vì các thay đổi chỉ ảnh hưởng đến chức năng liên quan.\n\nLưu ý bổ sung:\n\nChức năng có thể có từ 0 đến nhiều tham số và một giá trị trả về duy nhất.\nChức năng có thể được định nghĩa bất cứ nơi nào trong mã của bạn, nhưng phải có thể truy cập được từ nơi chúng được gọi.\nRust áp dụng an toàn kiểu, đảm bảo tính tương thích kiểu giữa các tham số, đối số và giá trị trả về."
  },
  {
    "objectID": "posts/my-rust-book/index.html#functions-xây-dựng-các-khối-mã-tái-sử-dụng",
    "href": "posts/my-rust-book/index.html#functions-xây-dựng-các-khối-mã-tái-sử-dụng",
    "title": "My Rust Book",
    "section": "",
    "text": "Chức năng đóng vai trò là những viên gạch thiết yếu trong Rust, đóng gói các nhiệm vụ hoặc phép toán cụ thể. Chúng cho phép bạn cấu trúc mã hiệu quả, thúc đẩy tái sử dụng mã, đồng thời nâng cao khả năng đọc và bảo trì.\nKhái niệm chính:\n\nĐịnh nghĩa Chức năng:\n\nSử dụng từ khóa fn, tiếp theo là tên chức năng và dấu ngoặc đơn cho các tham số.\nDấu ngoặc nhọn {} bao quanh phần thân chức năng chứa mã được thực thi.\n\nChữ ký Chức năng:\n\nBao gồm tên chức năng, danh sách tham số (nếu có) và kiểu trả về (tùy chọn).\nVí dụ: fn plus_one(x: i32) -&gt; i32\n\nplus_one: Tên chức năng\nx: i32: Tham số tên x có kiểu i32 (số nguyên)\n-&gt; i32: Trả về giá trị i32\n\n\nTham số và Đối số:\n\nTham số là các biến được định nghĩa trong chữ ký chức năng.\nĐối số là các giá trị thực tế được truyền khi gọi chức năng.\nVí dụ: plus_one(5) truyền đối số 5 cho tham số x.\n\nGiá trị Trả về:\n\nChức năng có thể tùy chọn trả về giá trị bằng cách sử dụng từ khóa return hoặc ngầm định thông qua biểu thức cuối cùng.\nKiểu trả về phải được chỉ định sau mũi tên -&gt; trong chữ ký.\n\n\nVí dụ: Cộng hai số\nfn add(x: i32, y: i32) -&gt; i32 {\n    x + y\n}\n\nfn main() {\n    let sum = add(5, 3); // Gọi hàm add với các đối số 5 và 3\n    println!(\"Tổng là: {}\", sum);\n}\nGiải thích:\n\nHàm add lấy hai tham số i32 (x và y) và trả về giá trị i32.\nBên trong hàm, x và y được cộng lại và kết quả được trả về.\nTrong hàm main, add được gọi với các đối số 5 và 3, gán tổng trả về cho biến sum.\nGiá trị của sum được in ra bằng println!.\n\nGọi Chức năng:\n\nĐể gọi một chức năng, hãy sử dụng tên của nó theo sau là dấu ngoặc đơn chứa các đối số theo đúng thứ tự và kiểu.\nĐối số được đánh giá trước khi được truyền cho chức năng.\n\nLợi ích của việc sử dụng Chức năng:\n\nTái sử dụng Mã: Định nghĩa một chức năng một lần và gọi nó từ nhiều vị trí trong mã của bạn.\nKhả năng đọc được cải thiện: Chia nhỏ các khối mã lớn thành các chức năng nhỏ hơn được đặt tên tốt, giúp mã dễ hiểu hơn.\nKhả năng bảo trì: Việc sửa đổi dễ dàng hơn khi mã được tổ chức thành các chức năng, vì các thay đổi chỉ ảnh hưởng đến chức năng liên quan.\n\nLưu ý bổ sung:\n\nChức năng có thể có từ 0 đến nhiều tham số và một giá trị trả về duy nhất.\nChức năng có thể được định nghĩa bất cứ nơi nào trong mã của bạn, nhưng phải có thể truy cập được từ nơi chúng được gọi.\nRust áp dụng an toàn kiểu, đảm bảo tính tương thích kiểu giữa các tham số, đối số và giá trị trả về."
  },
  {
    "objectID": "posts/my-rust-book/index.html#mở-rộng-về-enum-trong-rust-ví-dụ-thực-tế-và-ứng-dụng-nâng-cao",
    "href": "posts/my-rust-book/index.html#mở-rộng-về-enum-trong-rust-ví-dụ-thực-tế-và-ứng-dụng-nâng-cao",
    "title": "My Rust Book",
    "section": "",
    "text": "Ví dụ thực tế:\nGiả sử bạn đang xây dựng một ứng dụng quản lý thư viện. Bạn cần lưu trữ thông tin về sách, bao gồm tiêu đề, tác giả, ngày xuất bản và ISBN. Bạn có thể sử dụng một struct để biểu diễn thông tin này:\nstruct Book {\n    title: String,\n    author: String,\n    published_date: String,\n    isbn: String,\n}\nTuy nhiên, struct này không thể biểu diễn trường hợp sách không có ISBN. Để giải quyết vấn đề này, bạn có thể sử dụng enum Option&lt;T&gt;:\nenum BookInfo {\n    Book(Book),\n    NoIsbn(String),\n}\n\nlet book_with_isbn = BookInfo::Book(Book {\n    title: String::from(\"The Rust Programming Language\"),\n    author: String::from(\"Steve Klabnik and Carol Nichols\"),\n    published_date: String::from(\"2018-05-01\"),\n    isbn: String::from(\"978-1-492-04033-1\"),\n});\n\nlet book_without_isbn = BookInfo::NoIsbn(String::from(\"The Art of Computer Programming\"));\nVới enum BookInfo, bạn có thể biểu diễn cả hai trường hợp: sách có ISBN và sách không có ISBN. Điều này giúp mã của bạn rõ ràng và dễ hiểu hơn.\nỨng dụng nâng cao:\nEnum có thể được sử dụng cho nhiều mục đích khác nhau, bao gồm:\n\nBiểu diễn trạng thái: Enum có thể được sử dụng để biểu diễn trạng thái của một hệ thống, chẳng hạn như trạng thái của một nút trong giao diện người dùng hoặc trạng thái của một yêu cầu mạng.\nLỗi xử lý: Enum có thể được sử dụng để biểu diễn các lỗi khác nhau có thể xảy ra trong chương trình của bạn.\nMô hình hóa dữ liệu phức tạp: Enum có thể được sử dụng để mô hình hóa dữ liệu phức tạp, chẳng hạn như cấu trúc cây hoặc biểu đồ.\n\nVí dụ về việc sử dụng enum để biểu diễn trạng thái:\nenum ButtonState {\n    Idle,\n    Pressed,\n    Disabled,\n}\n\nlet mut button_state = ButtonState::Idle;\n\n// Xử lý sự kiện click chuột\nbutton_state = ButtonState::Pressed;\n\n// Xử lý sự kiện nhả chuột\nbutton_state = ButtonState::Idle;\n\n// Vô hiệu hóa nút\nbutton_state = ButtonState::Disabled;\nEnum ButtonState có thể được sử dụng để biểu diễn trạng thái của một nút trong giao diện người dùng. Nó có ba biến thể: Idle, Pressed và Disabled.\nVí dụ về việc sử dụng enum để xử lý lỗi:\nenum Error {\n    IoError,\n    ParseError,\n    NetworkError,\n}\n\nfn read_file(filename: &str) -&gt; Result&lt;String, Error&gt; {\n    // ...\n}\n\nmatch read_file(\"myfile.txt\") {\n    Ok(contents) =&gt; {\n        // Xử lý nội dung tệp\n    },\n    Err(error) =&gt; {\n        // Xử lý lỗi\n        match error {\n            Error::IoError =&gt; {\n                // ...\n            },\n            Error::ParseError =&gt; {\n                // ...\n            },\n            Error::NetworkError =&gt; {\n                // ...\n            },\n        }\n    },\n}\nEnum Error có thể được sử dụng để biểu diễn các lỗi khác nhau có thể xảy ra trong hàm read_file.\nKết luận:\nEnum là một công cụ mạnh mẽ và linh hoạt có thể được sử dụng cho nhiều mục đích khác nhau trong Rust. Chúng giúp mã của bạn rõ ràng, dễ hiểu và dễ bảo trì hơn.\nNgoài ra:\n\nEnum có thể được sử dụng để tạo các kiểu dữ liệu tùy chỉnh của riêng bạn.\nEnum có thể được sử dụng để biểu diễn các tập hợp giá trị hữu hạn.\nEnum có thể được sử dụng để cải thiện hiệu suất của chương trình của bạn."
  },
  {
    "objectID": "posts/my-rust-book/index.html#phân-tích-chuyên-sâu-về-cấu-trúc-điều-khiển-match-trong-rust",
    "href": "posts/my-rust-book/index.html#phân-tích-chuyên-sâu-về-cấu-trúc-điều-khiển-match-trong-rust",
    "title": "My Rust Book",
    "section": "",
    "text": "Ví dụ thực tế:\nGiả sử bạn đang xây dựng một ứng dụng quản lý thư viện. Bạn cần lưu trữ thông tin về sách, bao gồm tiêu đề, tác giả, ngày xuất bản và ISBN. Bạn có thể sử dụng match để xác định loại sách và xử lý thông tin tương ứng:\nenum BookInfo {\n    Book {\n        title: String,\n        author: String,\n        published_date: String,\n        isbn: String,\n    },\n    Ebook {\n        title: String,\n        author: String,\n        published_date: String,\n        file_format: String,\n    },\n}\n\nlet book_info = BookInfo::Ebook {\n    title: String::from(\"The Rust Programming Language\"),\n    author: String::from(\"Steve Klabnik and Carol Nichols\"),\n    published_date: String::from(\"2018-05-01\"),\n    file_format: String::from(\"EPUB\"),\n};\n\nmatch book_info {\n    BookInfo::Book { title, author, published_date, isbn } =&gt; {\n        println!(\"Sách in:\");\n        println!(\"Tiêu đề: {}\", title);\n        println!(\"Tác giả: {}\", author);\n        println!(\"Ngày xuất bản: {}\", published_date);\n        println!(\"ISBN: {}\", isbn);\n    },\n    BookInfo::Ebook { title, author, published_date, file_format } =&gt; {\n        println!(\"Sách điện tử:\");\n        println!(\"Tiêu đề: {}\", title);\n        println!(\"Tác giả: {}\", author);\n        println!(\"Ngày xuất bản: {}\", published_date);\n        println!(\"Định dạng tệp: {}\", file_format);\n    },\n}\nMở rộng khả năng:\n\nKết hợp với if: Sử dụng if để kiểm tra điều kiện trước khi khớp mẫu với match:\n\nlet number = 5;\n\nif number &gt; 0 {\n    match number {\n        1 =&gt; println!(\"Số một\"),\n        2 =&gt; println!(\"Số hai\"),\n        _ =&gt; println!(\"Số lớn hơn hai\"),\n    }\n} else {\n    println!(\"Số âm\");\n}\n\nKhớp với các kiểu dữ liệu phức tạp: match có thể sử dụng để khớp với các cấu trúc dữ liệu phức tạp như struct, enum, vec, v.v.\nLấy giá trị từ các biến thể enum: Sử dụng match để trích xuất giá trị từ các biến thể enum khác nhau.\n\nVí dụ nâng cao:\nGiả sử bạn đang viết một chương trình cờ vua. Bạn có thể sử dụng match để xác định vị trí của quân cờ trên bàn cờ và thực hiện các di chuyển hợp lệ:\nenum Square {\n    A1, B1, C1, ..., H8,\n}\n\nlet position = Square::E4;\n\nmatch position {\n    Square::A1 =&gt; println!(\"Quân cờ ở góc trên bên trái\"),\n    Square::E4 =&gt; println!(\"Quân cờ ở trung tâm\"),\n    Square::H8 =&gt; println!(\"Quân cờ ở góc dưới bên phải\"),\n    _ =&gt; println!(\"Quân cờ ở vị trí khác\"),\n}\nKết luận:\nmatch là một công cụ mạnh mẽ và linh hoạt trong Rust. Hiểu rõ cách sử dụng match có thể giúp bạn viết mã rõ ràng, súc tích và dễ bảo trì.\nTài liệu tham khảo:\n\nThe Rust Programming Language - Chapter 18: Control Flow: [đã xoá URL không hợp lệ]\nThe Rust Reference - The match Statement: [đã xoá URL không hợp lệ]\n\nLưu ý:\n\nTránh lặp lại những thông tin đã được đề cập trong phần trả lời trước.\nCung cấp thêm ví dụ thực tế để minh họa các trường hợp sử dụng khác nhau của match.\nGiải thích cách sử dụng match với các kiểu dữ liệu và cấu trúc phức tạp.\nĐề xuất tài liệu tham khảo để người đọc tìm hiểu thêm.\n\nĐộ dài:\nCâu trả lời này dài hơn câu trả lời trước và cung cấp thêm thông tin chi tiết về match, bao gồm ví dụ thực tế, cách mở rộng khả năng và tài liệu tham khảo."
  },
  {
    "objectID": "posts/my-rust-book/index.html#kiểm-soát-luồng-ngắn-gọn-với-if-let",
    "href": "posts/my-rust-book/index.html#kiểm-soát-luồng-ngắn-gọn-với-if-let",
    "title": "My Rust Book",
    "section": "",
    "text": "Cú pháp if let cho phép bạn kết hợp if và let thành một cách ngắn gọn hơn để xử lý các giá trị khớp với một mẫu nhất định trong khi bỏ qua những giá trị còn lại. Hãy xem xét chương trình trong Liệt kê 6-6, chương trình này khớp với một giá trị Option&lt;u8&gt; trong biến config_max nhưng chỉ muốn thực thi mã nếu biến này có giá trị là Some.\nlet config_max = Some(3u8);\nmatch config_max {\n    Some(max) =&gt; println!(\"Giá trị tối đa được cấu hình là {}\", max),\n    _ =&gt; (),\n}\nLiệt kê 6-6: Một câu lệnh match chỉ thực thi mã khi giá trị là Some\nNếu giá trị là Some, chúng ta in ra giá trị trong biến thể Some bằng cách gán giá trị cho biến max trong mẫu. Chúng ta không muốn làm gì với giá trị None. Để thỏa mãn biểu thức match, chúng ta phải thêm _ =&gt; () sau khi xử lý chỉ một biến thể, đây là đoạn mã thừa đáng chán để thêm vào.\nThay vào đó, chúng ta có thể viết ngắn gọn hơn bằng cách sử dụng if let. Đoạn mã sau đây hoạt động giống như match trong Liệt kê 6-6:\nlet config_max = Some(3u8);\nif let Some(max) = config_max {\n    println!(\"Giá trị tối đa được cấu hình là {}\", max);\n}\nCú pháp if let lấy một mẫu và một biểu thức được phân tách bằng dấu bằng. Nó hoạt động tương tự như match, trong đó biểu thức được đưa vào match và mẫu là nhánh đầu tiên của nó. Trong trường hợp này, mẫu là Some(max), và max được gán cho giá trị bên trong Some. Sau đó, chúng ta có thể sử dụng max trong thân khối của if let theo cùng cách chúng ta sử dụng max trong nhánh match tương ứng. Khối mã trong khối if let không được chạy nếu giá trị không khớp với mẫu.\nSử dụng if let có nghĩa là ít gõ phím hơn, ít thụt lề hơn và ít mã thừa hơn. Tuy nhiên, bạn sẽ mất đi tính năng kiểm tra toàn diện mà match cung cấp. Việc lựa chọn giữa match và if let phụ thuộc vào những gì bạn đang làm trong tình huống cụ thể của mình và liệu việc đạt được sự ngắn gọn có phải là một đánh đổi phù hợp để mất đi kiểm tra toàn diện hay không.\nNói cách khác, bạn có thể coi if let như cú pháp rút gọn cho một câu lệnh match chạy mã khi giá trị khớp với một mẫu và sau đó bỏ qua tất cả các giá trị khác.\nChúng ta có thể bao gồm một khối else với if let. Khối mã đi kèm với else giống như khối mã sẽ đi với trường hợp _ trong biểu thức match tương đương với if let và else. Nhớ lại định nghĩa enum Coin trong Liệt kê 6-4, trong đó biến thể Quarter cũng chứa một giá trị UsState. Nếu chúng ta muốn đếm tất cả các đồng xu không phải đồng 25 xu trong khi thông báo trạng thái của các đồng 25 xu, chúng ta có thể thực hiện điều đó bằng biểu thức match như sau:\nlet mut count = 0;\nmatch coin {\n    Coin::Quarter(state) =&gt; println!(\"Đồng 25 xu của bang {:?}!\", state),\n    _ =&gt; count += 1,\n}\nHoặc chúng ta có thể sử dụng biểu thức if let và else như sau:\nlet mut count = 0;\nif let Coin::Quarter(state) = coin {\n    println!(\"Đồng 25 xu của bang {:?}!\", state);\n} else {\n    count += 1;\n}\nNếu bạn gặp phải tình huống chương trình của bạn có logic quá phức tạp để thể hiện bằng match, hãy nhớ rằng if let cũng nằm trong hộp công cụ Rust của bạn."
  }
]